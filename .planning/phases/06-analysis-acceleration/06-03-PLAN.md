---
phase: 06-analysis-acceleration
plan: 03
type: execute
wave: 2
depends_on:
  - "06-01"
  - "06-02"
files_modified:
  - app/api/routes.py
  - app/static/js/document.js
  - app/static/css/main.css
autonomous: true

must_haves:
  truths:
    - "User sees a progress bar during analysis that updates in real-time"
    - "Progress bar shows percentage complete with batch count"
    - "User sees risks appear incrementally as batches complete"
    - "Progress includes skip statistics showing how many paragraphs were filtered"
    - "User can see estimated time remaining during analysis"
  artifacts:
    - path: "app/api/routes.py"
      provides: "Enhanced progress endpoint with incremental results"
      contains: "incremental_risks"
    - path: "app/static/js/document.js"
      provides: "Real-time progress polling and incremental risk display"
      contains: "pollProgress"
    - path: "app/static/css/main.css"
      provides: "Progress bar styling"
      contains: "progress-bar"
  key_links:
    - from: "app/static/js/document.js"
      to: "/api/analysis/{session_id}/progress"
      via: "fetch polling"
      pattern: "api/analysis.*progress"
    - from: "app/api/routes.py"
      to: "app/services/claude_service.py progress tracking"
      via: "get_progress function"
      pattern: "get_progress"
---

<objective>
Implement real-time progress indicators and incremental results display so users see analysis progress and risks populate as each batch completes.

Purpose: Long-running analysis (even at 5 minutes) needs user feedback. Progress bars reduce perceived wait time and incremental results let users start reviewing before analysis completes.

Output: Enhanced progress endpoint, real-time polling in frontend, incremental risk display in the sidebar.
</objective>

<execution_context>
@C:\Users\david\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\david\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-analysis-acceleration/06-RESEARCH.md
@.planning/phases/06-analysis-acceleration/06-01-SUMMARY.md (if exists)
@.planning/phases/06-analysis-acceleration/06-02-SUMMARY.md (if exists)

Key context:
- Progress tracking already exists in claude_service.py (analysis_progress dict, update_progress function)
- /api/analysis/{session_id}/progress endpoint already exists in routes.py
- Frontend already has an analysis overlay - we're enhancing it with better progress display
- Plan 01 added skip_stats to progress
- Plan 02 added parallel execution with batch progress

Existing progress structure (from claude_service.py):
```python
{
    'status': 'analyzing|complete',
    'total_paragraphs': int,
    'total_batches': int,
    'current_batch': int,
    'paragraphs_processed': int,
    'risks_found': int,
    'percent': int,
    'elapsed_seconds': int,
    'estimated_remaining_seconds': int,
    'current_action': str,
    'skip_stats': dict  # Added by Plan 01
}
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance progress endpoint with incremental results</name>
  <files>app/api/routes.py</files>
  <action>
Enhance the `/api/analysis/{session_id}/progress` endpoint to include incremental risk results.

Modify the `get_analysis_progress()` function (around line 393-416) to:

1. Include partial risks found so far in the response:
   ```python
   from app.services.claude_service import get_progress, get_partial_risks

   @api_bp.route('/analysis/<session_id>/progress', methods=['GET'])
   def get_analysis_progress(session_id):
       progress = get_progress(session_id)
       if not progress:
           # existing handling...

       # Add incremental risks if available
       include_risks = request.args.get('include_risks', 'false').lower() == 'true'
       if include_risks and progress.get('status') == 'analyzing':
           progress['incremental_risks'] = get_partial_risks(session_id)

       return jsonify(progress)
   ```

2. Add a helper function to claude_service.py for getting partial risks (see Task 2)

3. Ensure skip_stats from Plan 01 are included in the progress response (they should already be there via update_progress)

4. Format estimated_remaining_seconds as human-readable in the response:
   ```python
   if progress.get('estimated_remaining_seconds'):
       remaining = progress['estimated_remaining_seconds']
       if remaining > 60:
           progress['estimated_remaining_display'] = f"{remaining // 60}m {remaining % 60}s"
       else:
           progress['estimated_remaining_display'] = f"{remaining}s"
   ```
  </action>
  <verify>
Check endpoint exists and returns expected fields.
Run: `grep -n "incremental_risks\|estimated_remaining_display" app/api/routes.py` should show the new fields.
  </verify>
  <done>Progress endpoint returns incremental risks when requested and human-readable time estimates</done>
</task>

<task type="auto">
  <name>Task 2: Add partial results tracking to claude_service</name>
  <files>app/services/claude_service.py</files>
  <action>
Add functionality to store and retrieve partial analysis results during processing.

1. Add a global dict to store partial risks (similar to analysis_progress):
   ```python
   # Global partial results tracker
   partial_results = {}
   partial_results_lock = threading.Lock()

   def add_partial_risks(session_id: str, risks: List[Dict]):
       """Add risks from a completed batch to partial results."""
       with partial_results_lock:
           if session_id not in partial_results:
               partial_results[session_id] = []
           partial_results[session_id].extend(risks)

   def get_partial_risks(session_id: str) -> List[Dict]:
       """Get all risks found so far for a session."""
       with partial_results_lock:
           return partial_results.get(session_id, []).copy()

   def clear_partial_risks(session_id: str):
       """Clear partial risks for a session."""
       with partial_results_lock:
           if session_id in partial_results:
               del partial_results[session_id]
   ```

2. In analyze_document_with_llm(), after processing each batch (both parallel and sequential paths):
   - Call `add_partial_risks(session_id, batch_result.get('risks', []))` after parsing each batch result
   - Call `clear_partial_risks(session_id)` at the end of analysis (after all batches complete)

3. Export the new functions in the module's public interface.
  </action>
  <verify>
Run: `python -c "from app.services.claude_service import get_partial_risks, add_partial_risks, clear_partial_risks; print('Partial results functions available')"`
  </verify>
  <done>claude_service.py tracks partial risks during analysis and exposes get_partial_risks() function</done>
</task>

<task type="auto">
  <name>Task 3: Implement real-time progress UI with incremental results</name>
  <files>app/static/js/document.js, app/static/css/main.css</files>
  <action>
Enhance the frontend to show real-time progress with incremental risk display.

In `app/static/js/document.js`:

1. Add/enhance the progress polling function:
   ```javascript
   let progressPollInterval = null;
   let displayedRiskIds = new Set(); // Track which risks are already shown

   async function pollProgress(sessionId) {
       try {
           const response = await fetch(`/api/analysis/${sessionId}/progress?include_risks=true`);
           const progress = await response.json();

           updateProgressDisplay(progress);

           // Display incremental risks
           if (progress.incremental_risks && progress.incremental_risks.length > 0) {
               displayIncrementalRisks(progress.incremental_risks);
           }

           if (progress.status === 'complete') {
               clearInterval(progressPollInterval);
               progressPollInterval = null;
               displayedRiskIds.clear();
               // Trigger full analysis load
               loadAnalysis(sessionId);
           }
       } catch (error) {
           console.error('Progress poll error:', error);
       }
   }

   function startProgressPolling(sessionId) {
       displayedRiskIds.clear();
       if (progressPollInterval) clearInterval(progressPollInterval);
       progressPollInterval = setInterval(() => pollProgress(sessionId), 1000); // Poll every second
   }
   ```

2. Add progress display update function:
   ```javascript
   function updateProgressDisplay(progress) {
       const overlay = document.getElementById('analysis-overlay');
       const progressBar = overlay.querySelector('.progress-bar-fill');
       const statusText = overlay.querySelector('.progress-status');
       const detailText = overlay.querySelector('.progress-details');

       if (progressBar) {
           progressBar.style.width = `${progress.percent || 0}%`;
       }

       if (statusText) {
           statusText.textContent = progress.current_action || 'Analyzing...';
       }

       if (detailText) {
           let details = [];
           if (progress.current_batch && progress.total_batches) {
               details.push(`Batch ${progress.current_batch}/${progress.total_batches}`);
           }
           if (progress.risks_found) {
               details.push(`${progress.risks_found} risks found`);
           }
           if (progress.estimated_remaining_display) {
               details.push(`~${progress.estimated_remaining_display} remaining`);
           }
           if (progress.skip_stats) {
               const skipped = Object.values(progress.skip_stats).reduce((a, b) => a + b, 0);
               if (skipped > 0) {
                   details.push(`${skipped} paragraphs filtered`);
               }
           }
           detailText.textContent = details.join(' | ');
       }
   }
   ```

3. Add incremental risk display function:
   ```javascript
   function displayIncrementalRisks(risks) {
       const sidebar = document.querySelector('.risk-sidebar') || document.querySelector('#risk-panel');
       if (!sidebar) return;

       risks.forEach(risk => {
           if (displayedRiskIds.has(risk.risk_id)) return;
           displayedRiskIds.add(risk.risk_id);

           // Add risk to sidebar with fade-in animation
           const riskElement = createRiskElement(risk);
           riskElement.classList.add('risk-item-new');
           sidebar.appendChild(riskElement);

           // Remove animation class after animation completes
           setTimeout(() => riskElement.classList.remove('risk-item-new'), 500);
       });
   }
   ```

4. Update the analysis trigger to start polling:
   - Find where analysis is initiated (likely in loadDocument or similar)
   - Before calling the analysis endpoint, call `startProgressPolling(sessionId)`

In `app/static/css/main.css`:

5. Add progress bar and animation styles:
   ```css
   /* Progress bar styles */
   .progress-container {
       width: 100%;
       background: #e0e0e0;
       border-radius: 4px;
       overflow: hidden;
       margin: 16px 0;
   }

   .progress-bar-fill {
       height: 8px;
       background: linear-gradient(90deg, #2563eb, #3b82f6);
       border-radius: 4px;
       transition: width 0.3s ease-out;
   }

   .progress-status {
       font-size: 14px;
       color: #374151;
       margin-bottom: 4px;
   }

   .progress-details {
       font-size: 12px;
       color: #6b7280;
   }

   /* Incremental risk animation */
   .risk-item-new {
       animation: fadeIn 0.3s ease-out;
   }

   @keyframes fadeIn {
       from {
           opacity: 0;
           transform: translateY(-10px);
       }
       to {
           opacity: 1;
           transform: translateY(0);
       }
   }
   ```
  </action>
  <verify>
1. Check CSS has progress styles: `grep -n "progress-bar-fill" app/static/css/main.css`
2. Check JS has polling: `grep -n "pollProgress" app/static/js/document.js`
  </verify>
  <done>Frontend shows real-time progress bar, time estimates, and risks appear incrementally as batches complete</done>
</task>

</tasks>

<verification>
1. Progress endpoint returns incremental_risks when include_risks=true
2. Progress endpoint returns human-readable time estimate
3. Frontend polls progress every second during analysis
4. Progress bar updates visually with percentage
5. Risks appear in sidebar as batches complete (not all at once at end)
6. Skip stats are visible in progress details
</verification>

<success_criteria>
1. User sees a visual progress bar during analysis
2. Progress bar shows percentage with batch count (e.g., "Batch 5/30")
3. Estimated time remaining is displayed (e.g., "~2m 30s remaining")
4. Skip statistics show how many paragraphs were filtered (e.g., "45 paragraphs filtered")
5. Risks appear in the sidebar incrementally as batches complete
6. New risks animate in smoothly (fade-in effect)
7. Progress polling stops when analysis completes
</success_criteria>

<output>
After completion, create `.planning/phases/06-analysis-acceleration/06-03-SUMMARY.md`
</output>
