---
phase: 06-analysis-acceleration
plan: 04
type: execute
wave: 3
depends_on:
  - "06-03"
files_modified:
  - app/services/claude_service.py
  - app/api/routes.py
  - app/static/js/document.js
  - app/static/css/main.css
autonomous: true

must_haves:
  truths:
    - "User sees a progress bar during analysis that updates in real-time"
    - "Progress shows distinct stages: initial analysis, parallel batches"
    - "User sees risks appear incrementally as batches complete"
    - "Progress includes skip statistics showing how many paragraphs were filtered"
    - "User can see batch completion count during parallel execution"
  artifacts:
    - path: "app/services/claude_service.py"
      provides: "Partial results tracking functions"
      contains: "get_partial_risks"
    - path: "app/api/routes.py"
      provides: "Enhanced progress endpoint with incremental results"
      contains: "incremental_risks"
    - path: "app/static/js/document.js"
      provides: "Real-time progress polling and incremental risk display"
      contains: "pollProgress"
    - path: "app/static/css/main.css"
      provides: "Progress bar styling"
      contains: "progress-bar"
  key_links:
    - from: "app/static/js/document.js"
      to: "/api/analysis/{session_id}/progress"
      via: "fetch polling"
      pattern: "api/analysis.*progress"
    - from: "app/api/routes.py"
      to: "app/services/claude_service.py partial tracking"
      via: "get_partial_risks function"
      pattern: "get_partial_risks"
---

<objective>
Implement real-time progress indicators and incremental results display so users see analysis progress across both initial analysis and parallel batch stages.

Purpose: Even with 90-second analysis, users need feedback. The two-stage architecture (initial + parallel) requires clear progress indication for each stage. Incremental results let users start reviewing before analysis completes.

Output: Enhanced progress endpoint, real-time polling in frontend, incremental risk display in the sidebar.
</objective>

<execution_context>
@C:\Users\david\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\david\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-analysis-acceleration/06-RESEARCH.md
@.planning/phases/06-analysis-acceleration/06-01-SUMMARY.md (if exists)
@.planning/phases/06-analysis-acceleration/06-02-SUMMARY.md (if exists)
@.planning/phases/06-analysis-acceleration/06-03-SUMMARY.md (if exists)

Key context:
- Progress tracking already exists in claude_service.py (analysis_progress dict, update_progress function)
- /api/analysis/{session_id}/progress endpoint already exists in routes.py
- Frontend already has an analysis overlay - we're enhancing it with better progress display
- Plan 01 added skip_stats to progress
- Plan 02 added initial_analysis stage with 'stage' field
- Plan 03 added parallel batch progress with batch counts

New progress structure (from Plans 01-03):
```python
{
    'status': 'analyzing|complete',
    'stage': 'initial_analysis|parallel_batches|complete',
    'total_paragraphs': int,
    'total_batches': int,
    'current_batch': int,
    'paragraphs_processed': int,
    'risks_found': int,
    'percent': int,
    'elapsed_seconds': int,
    'current_action': str,
    'skip_stats': dict,           # From Plan 01
    'initial_analysis_complete': bool,  # From Plan 02
    'defined_terms_count': int,   # From Plan 02
}
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add partial results tracking to claude_service</name>
  <files>app/services/claude_service.py</files>
  <action>
Add functionality to store and retrieve partial analysis results during processing.

1. Add a global dict to store partial risks (similar to analysis_progress):
   ```python
   # Global partial results tracker
   partial_results = {}
   partial_results_lock = threading.Lock()

   def add_partial_risks(session_id: str, risks: List[Dict]):
       """Add risks from a completed batch to partial results."""
       with partial_results_lock:
           if session_id not in partial_results:
               partial_results[session_id] = []
           partial_results[session_id].extend(risks)

   def get_partial_risks(session_id: str) -> List[Dict]:
       """Get all risks found so far for a session."""
       with partial_results_lock:
           return partial_results.get(session_id, []).copy()

   def clear_partial_risks(session_id: str):
       """Clear partial risks for a session."""
       with partial_results_lock:
           if session_id in partial_results:
               del partial_results[session_id]
   ```

2. In the forked parallel path (from Plan 03), update the progress_callback to also add partial risks:
   ```python
   def progress_callback(progress_data, batch_result=None):
       if session_id:
           # Existing progress update...

           # Add partial risks from completed batch
           if batch_result and batch_result.get('success') and batch_result.get('risks'):
               add_partial_risks(session_id, batch_result['risks'])
   ```

3. In the sequential path (fallback), also add partial risks after each batch:
   ```python
   # After parsing batch_result:
   if session_id:
       add_partial_risks(session_id, batch_result.get('risks', []))
   ```

4. At the end of analyze_document_with_llm(), clear partial risks:
   ```python
   # Clear partial results at end of analysis
   if session_id:
       clear_partial_risks(session_id)
   ```

5. Export the new functions in the module's public interface.
  </action>
  <verify>
Run: `python -c "from app.services.claude_service import get_partial_risks, add_partial_risks, clear_partial_risks; print('Partial results functions available')"`
  </verify>
  <done>claude_service.py tracks partial risks during analysis and exposes get_partial_risks() function</done>
</task>

<task type="auto">
  <name>Task 2: Enhance progress endpoint with incremental results</name>
  <files>app/api/routes.py</files>
  <action>
Enhance the `/api/analysis/{session_id}/progress` endpoint to include incremental risk results.

Modify the `get_analysis_progress()` function (around line 393-416) to:

1. Import the partial risks function created in Task 1:
   ```python
   from app.services.claude_service import get_progress, get_partial_risks
   ```

2. Include partial risks found so far in the response:
   ```python
   @api_bp.route('/analysis/<session_id>/progress', methods=['GET'])
   def get_analysis_progress(session_id):
       progress = get_progress(session_id)
       if not progress:
           # existing handling...

       # Add incremental risks if available
       include_risks = request.args.get('include_risks', 'false').lower() == 'true'
       if include_risks and progress.get('status') == 'analyzing':
           progress['incremental_risks'] = get_partial_risks(session_id)

       return jsonify(progress)
   ```

3. Add stage-aware display messages:
   ```python
   # Add human-readable stage description
   stage = progress.get('stage')
   if stage == 'initial_analysis':
       progress['stage_display'] = 'Analyzing full document structure...'
   elif stage == 'parallel_batches':
       batch = progress.get('current_batch', 0)
       total = progress.get('total_batches', 0)
       progress['stage_display'] = f'Running parallel analysis ({batch}/{total} batches)'
   else:
       progress['stage_display'] = progress.get('current_action', 'Processing...')
   ```

4. Format estimated_remaining_seconds as human-readable in the response:
   ```python
   if progress.get('elapsed_seconds'):
       elapsed = progress['elapsed_seconds']
       if elapsed > 60:
           progress['elapsed_display'] = f"{elapsed // 60}m {elapsed % 60}s"
       else:
           progress['elapsed_display'] = f"{elapsed}s"
   ```
  </action>
  <verify>
Check endpoint exists and returns expected fields.
Run: `grep -n "incremental_risks\|stage_display" app/api/routes.py` should show the new fields.
  </verify>
  <done>Progress endpoint returns incremental risks when requested and stage-aware display messages</done>
</task>

<task type="auto">
  <name>Task 3: Implement real-time progress UI with incremental results</name>
  <files>app/static/js/document.js, app/static/css/main.css</files>
  <action>
Enhance the frontend to show real-time progress with incremental risk display.

In `app/static/js/document.js`:

1. Add/enhance the progress polling function:
   ```javascript
   let progressPollInterval = null;
   let displayedRiskIds = new Set(); // Track which risks are already shown

   async function pollProgress(sessionId) {
       try {
           const response = await fetch(`/api/analysis/${sessionId}/progress?include_risks=true`);
           const progress = await response.json();

           updateProgressDisplay(progress);

           // Display incremental risks
           if (progress.incremental_risks && progress.incremental_risks.length > 0) {
               displayIncrementalRisks(progress.incremental_risks);
           }

           if (progress.status === 'complete') {
               clearInterval(progressPollInterval);
               progressPollInterval = null;
               displayedRiskIds.clear();
               // Trigger full analysis load
               loadAnalysis(sessionId);
           }
       } catch (error) {
           console.error('Progress poll error:', error);
       }
   }

   function startProgressPolling(sessionId) {
       displayedRiskIds.clear();
       if (progressPollInterval) clearInterval(progressPollInterval);
       progressPollInterval = setInterval(() => pollProgress(sessionId), 1000); // Poll every second
   }
   ```

2. Add progress display update function with stage awareness:
   ```javascript
   function updateProgressDisplay(progress) {
       const overlay = document.getElementById('analysis-overlay');
       if (!overlay) return;

       const progressBar = overlay.querySelector('.progress-bar-fill');
       const stageText = overlay.querySelector('.progress-stage');
       const statusText = overlay.querySelector('.progress-status');
       const detailText = overlay.querySelector('.progress-details');

       if (progressBar) {
           progressBar.style.width = `${progress.percent || 0}%`;
       }

       if (stageText) {
           stageText.textContent = progress.stage_display || 'Processing...';
       }

       if (statusText) {
           statusText.textContent = progress.current_action || 'Analyzing...';
       }

       if (detailText) {
           let details = [];

           // Show stage-specific info
           if (progress.stage === 'initial_analysis') {
               details.push('Establishing document context');
               if (progress.defined_terms_count) {
                   details.push(`${progress.defined_terms_count} defined terms found`);
               }
           } else if (progress.stage === 'parallel_batches') {
               if (progress.current_batch && progress.total_batches) {
                   details.push(`Batch ${progress.current_batch}/${progress.total_batches}`);
               }
               if (progress.risks_found) {
                   details.push(`${progress.risks_found} risks found`);
               }
           }

           if (progress.elapsed_display) {
               details.push(`Elapsed: ${progress.elapsed_display}`);
           }

           if (progress.skip_stats) {
               const skipped = Object.values(progress.skip_stats).reduce((a, b) => a + b, 0);
               if (skipped > 0) {
                   details.push(`${skipped} paragraphs filtered`);
               }
           }

           detailText.textContent = details.join(' | ');
       }
   }
   ```

3. Add incremental risk display function:
   ```javascript
   function displayIncrementalRisks(risks) {
       const sidebar = document.querySelector('.risk-sidebar') || document.querySelector('#risk-panel');
       if (!sidebar) return;

       risks.forEach(risk => {
           const riskId = risk.risk_id || risk.id;
           if (displayedRiskIds.has(riskId)) return;
           displayedRiskIds.add(riskId);

           // Add risk to sidebar with fade-in animation
           const riskElement = createRiskElement(risk);
           riskElement.classList.add('risk-item-new');
           sidebar.appendChild(riskElement);

           // Remove animation class after animation completes
           setTimeout(() => riskElement.classList.remove('risk-item-new'), 500);
       });
   }
   ```

4. Update the analysis trigger to start polling:
   - Find where analysis is initiated (likely in loadDocument or similar)
   - Before calling the analysis endpoint, call `startProgressPolling(sessionId)`

In `app/static/css/main.css`:

5. Add progress bar and animation styles:
   ```css
   /* Progress bar styles */
   .progress-container {
       width: 100%;
       background: #e0e0e0;
       border-radius: 4px;
       overflow: hidden;
       margin: 16px 0;
   }

   .progress-bar-fill {
       height: 8px;
       background: linear-gradient(90deg, #2563eb, #3b82f6);
       border-radius: 4px;
       transition: width 0.3s ease-out;
   }

   .progress-stage {
       font-size: 16px;
       font-weight: 600;
       color: #1f2937;
       margin-bottom: 8px;
   }

   .progress-status {
       font-size: 14px;
       color: #374151;
       margin-bottom: 4px;
   }

   .progress-details {
       font-size: 12px;
       color: #6b7280;
   }

   /* Two-stage progress indicator */
   .progress-stages {
       display: flex;
       gap: 16px;
       margin-bottom: 16px;
   }

   .progress-stages .stage {
       display: flex;
       align-items: center;
       gap: 8px;
       color: #9ca3af;
   }

   .progress-stages .stage.active {
       color: #2563eb;
   }

   .progress-stages .stage.complete {
       color: #10b981;
   }

   .progress-stages .stage-icon {
       width: 20px;
       height: 20px;
       border-radius: 50%;
       background: currentColor;
       display: flex;
       align-items: center;
       justify-content: center;
   }

   /* Incremental risk animation */
   .risk-item-new {
       animation: fadeIn 0.3s ease-out;
   }

   @keyframes fadeIn {
       from {
           opacity: 0;
           transform: translateY(-10px);
       }
       to {
           opacity: 1;
           transform: translateY(0);
       }
   }
   ```
  </action>
  <verify>
1. Check CSS has progress styles: `grep -n "progress-bar-fill" app/static/css/main.css`
2. Check JS has polling: `grep -n "pollProgress" app/static/js/document.js`
  </verify>
  <done>Frontend shows real-time progress bar with stage awareness, time display, and risks appear incrementally as batches complete</done>
</task>

</tasks>

<verification>
1. Partial risks functions can be imported from claude_service
2. Progress endpoint returns incremental_risks when include_risks=true
3. Progress endpoint returns stage_display and elapsed_display
4. Frontend polls progress every second during analysis
5. Progress bar updates visually with percentage
6. Stage indicator shows "Initial analysis" then "Parallel batches"
7. Risks appear in sidebar as batches complete (not all at once at end)
8. Skip stats are visible in progress details
</verification>

<success_criteria>
1. User sees a visual progress bar during analysis
2. Progress shows two distinct stages: initial analysis, parallel batches
3. Batch count visible during parallel stage (e.g., "Batch 15/30")
4. Elapsed time displayed (e.g., "Elapsed: 45s")
5. Skip statistics show filtered paragraphs (e.g., "38 paragraphs filtered")
6. Risks appear in the sidebar incrementally as batches complete
7. New risks animate in smoothly (fade-in effect)
8. Progress polling stops when analysis completes
</success_criteria>

<output>
After completion, create `.planning/phases/06-analysis-acceleration/06-04-SUMMARY.md`
</output>
