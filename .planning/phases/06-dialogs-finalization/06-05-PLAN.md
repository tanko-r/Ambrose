---
phase: 06-dialogs-finalization
plan: 05
type: execute
wave: 1
depends_on: ["06-02"]
files_modified:
  - frontend/src/components/dialogs/finalize-dialog.tsx
  - frontend/src/hooks/use-revision.ts
  - frontend/src/hooks/use-finalize.ts
  - frontend/src/lib/types.ts
  - frontend/src/lib/api.ts
  - frontend/src/lib/store.ts
  - app/api/routes.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Finalize dialog shows ALL approved revisions including those that were reopened then re-approved"
    - "Finalize dialog revision list is sourced from the Zustand store, not a separate backend fetch"
    - "Reopening a revision syncs to the backend via a POST /api/unaccept call"
    - "Accepting a revision with inline edits sends the edited text to the backend"
    - "Finalize dialog says 'Approved Revisions' not 'Accepted'"
    - "Stat boxes have clean alignment with icon above number and label"
    - "Revision accordion shows only the diff HTML, not redundant Original/Revised text"
    - "Author name field autofills from localStorage and persists across sessions"
    - "Export button is a dropdown: Export Redline, Export Clean, Export Both (default)"
  artifacts:
    - path: "frontend/src/components/dialogs/finalize-dialog.tsx"
      provides: "Finalize dialog with store-sourced revision list, clean stats, dropdown export, author autofill"
      contains: "Approved"
    - path: "frontend/src/hooks/use-revision.ts"
      provides: "reopen() with backend sync, accept() with edited text payload"
      contains: "unacceptRevision"
    - path: "app/api/routes.py"
      provides: "POST /api/unaccept endpoint and enhanced /api/accept endpoint"
      contains: "unaccept"
    - path: "frontend/src/lib/types.ts"
      provides: "UnacceptRequest/Response types, updated AcceptRequest with optional revised/editedHtml"
      contains: "UnacceptRequest"
    - path: "frontend/src/lib/api.ts"
      provides: "unacceptRevision API function, updated acceptRevision with edited text"
      contains: "unacceptRevision"
  key_links:
    - from: "frontend/src/hooks/use-revision.ts"
      to: "app/api/routes.py"
      via: "POST /api/unaccept"
      pattern: "unacceptRevision"
    - from: "frontend/src/hooks/use-revision.ts"
      to: "app/api/routes.py"
      via: "POST /api/accept with revised text"
      pattern: "acceptRevision"
    - from: "frontend/src/components/dialogs/finalize-dialog.tsx"
      to: "frontend/src/lib/store.ts"
      via: "useAppStore revisions selector"
      pattern: "useAppStore.*revisions"
---

<objective>
Fix the finalize dialog to use a single data source (store), add backend sync for reopen/accept-with-edits, fix all UI issues (terminology, alignment, redundant text, author autofill), and replace the export button with a dropdown offering Redline/Clean/Both options.

Purpose: Closes UAT gap from Test 5 (finalize dialog issues) and enhancement from Test 6 (export dropdown).
Output: Fully functional finalize dialog with consistent data, clean UI, and flexible export options.
</objective>

<execution_context>
@C:/Users/david/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/david/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-dialogs-finalization/06-02-SUMMARY.md
@.planning/phases/06-dialogs-finalization/06-UAT.md
@.planning/debug/finalize-dialog-issues.md
@frontend/src/components/dialogs/finalize-dialog.tsx
@frontend/src/hooks/use-revision.ts
@frontend/src/hooks/use-finalize.ts
@frontend/src/lib/types.ts
@frontend/src/lib/api.ts
@frontend/src/lib/store.ts
@app/api/routes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend unaccept endpoint + accept with edited text + frontend API wiring</name>
  <files>
    app/api/routes.py
    frontend/src/lib/types.ts
    frontend/src/lib/api.ts
    frontend/src/hooks/use-revision.ts
  </files>
  <action>
**Backend: Add POST /api/unaccept endpoint (routes.py)**

Read `app/api/routes.py`. Add a new endpoint AFTER the existing `/accept` endpoint (around line 735, before `/reject`):

```python
@api_bp.route('/unaccept', methods=['POST'])
def unaccept_revision():
    """
    Revert an accepted revision back to pending state.
    Called when user reopens an accepted revision for further editing.
    """
    data = request.get_json()
    session_id = data.get('session_id')
    para_id = data.get('para_id')

    session = get_session(session_id)
    if not session:
        return jsonify({'error': 'Session not found'}), 404

    revision = session.get('revisions', {}).get(para_id)
    if not revision:
        return jsonify({'error': 'Revision not found'}), 404

    revision['accepted'] = False
    save_session(session_id, session)

    return jsonify({
        'status': 'unaccepted',
        'para_id': para_id
    })
```

**Backend: Enhance POST /api/accept to receive edited text (routes.py)**

In the existing `accept_revision()` function (line ~678), after parsing `para_id` from the request data, also read optional `revised` and `diff_html` fields:

```python
revised_text = data.get('revised')
diff_html = data.get('diff_html')
```

Before the `revision['accepted'] = True` line, add:

```python
# Update revision text if user made inline edits
if revised_text is not None:
    revision['revised'] = revised_text
if diff_html is not None:
    revision['diff_html'] = diff_html
```

This ensures the backend has the user's edited text for export. The existing concept change detection still uses `revision.get('revised', '')` which will now reflect edits.

**Frontend types (types.ts):**

Read `frontend/src/lib/types.ts`. Add new types:

```typescript
export interface UnacceptRequest {
  session_id: string;
  para_id: string;
}

export interface UnacceptResponse {
  status: 'unaccepted';
  para_id: string;
}
```

Update `AcceptRequest` to include optional edited text fields:

```typescript
export interface AcceptRequest {
  session_id: string;
  para_id: string;
  revised?: string;       // User's edited revision text
  diff_html?: string;     // User's edited diff HTML
}
```

**Frontend API (api.ts):**

Read `frontend/src/lib/api.ts`. Add imports for `UnacceptRequest` and `UnacceptResponse`.

Add the unaccept function after `acceptRevision`:

```typescript
export async function unacceptRevision(data: UnacceptRequest): Promise<UnacceptResponse> {
  return request(`${FLASK_DIRECT}/api/unaccept`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
}
```

Note: Use `FLASK_DIRECT` (direct to Flask on :5000) like the other revision endpoints to avoid proxy timeout.

**Frontend hook (use-revision.ts):**

Read `frontend/src/hooks/use-revision.ts`. Make two changes:

1. **reopen() -- add backend sync:**

Import `unacceptRevision` from `@/lib/api`.

Change `reopen` from synchronous to async with backend call:

```typescript
const reopen = useCallback(async (paraId: string) => {
  const { sessionId, revisions, setRevision } = useAppStore.getState();
  const current = revisions[paraId];
  if (!current || !sessionId) return;

  // Optimistically update frontend immediately
  setRevision(paraId, { ...current, accepted: false });

  try {
    await unacceptRevision({ session_id: sessionId, para_id: paraId });
    toast.info("Revision reopened for editing");
  } catch (err) {
    // Revert on failure
    setRevision(paraId, { ...current, accepted: true });
    toast.error(err instanceof Error ? err.message : "Failed to reopen revision");
  }
}, []);
```

2. **accept() -- send edited text to backend:**

In the `accept` function, after persisting editedHtml to the store (lines 89-95), update the API call to include the edited text:

```typescript
// Read the latest state which may include edits
const latestBeforeApi = useAppStore.getState().revisions[paraId];

const result = await acceptRevision({
  session_id: sessionId,
  para_id: paraId,
  revised: latestBeforeApi?.revised,
  diff_html: latestBeforeApi?.editedHtml || latestBeforeApi?.diff_html,
});
```

This sends the user's edited text (if any) alongside the accept call, ensuring the backend has the same text as the frontend for export.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- routes.py has `/api/unaccept` endpoint that sets `accepted = False` and saves
- routes.py `/api/accept` reads optional `revised` and `diff_html` fields and updates revision
- types.ts has `UnacceptRequest`/`UnacceptResponse` interfaces
- types.ts `AcceptRequest` has optional `revised` and `diff_html` fields
- api.ts has `unacceptRevision` function using FLASK_DIRECT
- use-revision.ts `reopen()` calls `unacceptRevision` with optimistic update
- use-revision.ts `accept()` sends `revised` and `diff_html` in request
  </verify>
  <done>
- Backend and frontend are fully synced on revision accept/unaccept state
- Reopening a revision is reflected in both frontend store and backend session
- Accepting with inline edits sends the edited text to the backend for accurate export
- UnacceptRequest/Response types are defined and API client function exists
  </done>
</task>

<task type="auto">
  <name>Task 2: Finalize dialog UI fixes + store-sourced revision list + export dropdown + author autofill</name>
  <files>
    frontend/src/components/dialogs/finalize-dialog.tsx
    frontend/src/hooks/use-finalize.ts
    frontend/src/lib/store.ts
  </files>
  <action>
**finalize-dialog.tsx -- Full rework of the dialog UI:**

Read `frontend/src/components/dialogs/finalize-dialog.tsx`. Make these changes:

**A. Single data source -- use store for revision list (GAP FIX):**

Remove the `preview` state and the useEffect that fetches the backend preview. The revision list should come from the store, not the backend.

Build the revision list from the store's `revisions` record:

```typescript
const approvedRevisions = useMemo(() => {
  const sessionParagraphs = useAppStore.getState().paragraphs;
  return Object.entries(revisions)
    .filter(([, r]) => r.accepted)
    .map(([paraId, r]) => {
      // Look up section_ref from paragraphs
      const para = sessionParagraphs.find(p => p.id === paraId);
      return {
        para_id: paraId,
        section_ref: para?.section_ref ?? paraId,
        rationale: r.rationale,
        diff_html: r.editedHtml || r.diff_html,
      };
    });
}, [revisions]);
```

Remove `loading` state since there's no backend fetch on dialog open. Remove the preview fetch `useEffect`.

Keep `fetchPreview` from useFinalize but don't call it on open. The `doExport` and `download` functions are still needed.

**B. Rename "Accepted" to "Approved" (UI FIX):**

- Change "revisions accepted" label to "revisions approved" (stat box)
- Change "No accepted revisions to export." to "No approved revisions to export." (empty state)
- Update the DialogDescription: "Review your approved revisions and export Word documents."

**C. Fix stat box alignment (UI FIX):**

Redesign the stat boxes for cleaner alignment. Use a column layout with icon at top:

```tsx
<div className="flex gap-3">
  {/* Approved revisions */}
  <div className="flex-1 rounded-md border p-3 text-center">
    <CheckCircle2 className="mx-auto mb-1 h-5 w-5 text-green-600" />
    <div className="text-2xl font-semibold tabular-nums">{acceptedCount}</div>
    <div className="text-[11px] text-muted-foreground">revisions approved</div>
  </div>

  {/* Flags */}
  <div className="flex-1 rounded-md border p-3 text-center">
    <Flag className="mx-auto mb-1 h-5 w-5 text-blue-600" />
    <div className="text-2xl font-semibold tabular-nums">{flagCount}</div>
    <div className="text-[11px] text-muted-foreground">items flagged</div>
  </div>

  {/* Unreviewed */}
  <div className="flex-1 rounded-md border p-3 text-center">
    {unreviewedCount > 0 ? (
      <AlertTriangle className="mx-auto mb-1 h-5 w-5 text-amber-500" />
    ) : (
      <CheckCircle2 className="mx-auto mb-1 h-5 w-5 text-green-600" />
    )}
    <div className="text-2xl font-semibold tabular-nums">
      {unreviewedCount > 0 ? unreviewedCount : 0}
    </div>
    <div className="text-[11px] text-muted-foreground">
      {unreviewedCount > 0
        ? "risks not yet reviewed"
        : "all risks reviewed"}
    </div>
  </div>
</div>
```

Key changes:
- Center-aligned layout (icon above number above label)
- Always show a number (0 instead of empty string for the third box)
- Slightly larger number (text-2xl)
- Consistent structure across all three boxes

**D. Remove Original/Revised text from accordion (UI FIX):**

Delete the redundant original/revised text block from AccordionContent (current lines 185-196). Keep only the diff_html render:

```tsx
<AccordionContent className="px-3 pb-3">
  <div
    className="revision-diff text-sm leading-relaxed"
    dangerouslySetInnerHTML={{ __html: rev.diff_html }}
  />
</AccordionContent>
```

Also increase the diff text size from `text-xs` to `text-sm` for better readability.

**E. Author name autofill from localStorage (UI FIX):**

Replace `useState("")` with localStorage initialization:

```typescript
const [authorName, setAuthorName] = useState(() => {
  if (typeof window === 'undefined') return '';
  return localStorage.getItem('ambrose-author-name') ?? '';
});
```

Add a useEffect to persist changes:

```typescript
useEffect(() => {
  if (authorName) {
    localStorage.setItem('ambrose-author-name', authorName);
  }
}, [authorName]);
```

Add a TODO comment: `// TODO: Move author name to user settings/preferences page`

**F. Export dropdown button (Enhancement -- Test 6):**

Replace the single "Export Documents" button with a dropdown using shadcn DropdownMenu.

Import from the existing DropdownMenu component:
```typescript
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { ChevronDown } from "lucide-react";
```

Replace the export button in the footer:

```tsx
{!exported ? (
  <>
    <Button
      variant="outline"
      onClick={() => onOpenChange(false)}
      disabled={exporting}
    >
      Cancel
    </Button>
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button disabled={exporting || acceptedCount === 0}>
          {exporting && (
            <Loader2 className="mr-1.5 h-3.5 w-3.5 animate-spin" />
          )}
          Export
          <ChevronDown className="ml-1.5 h-3.5 w-3.5" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => handleExport('both')}>
          Export Both (Redline + Clean)
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => handleExport('track_changes')}>
          Export Redline Only
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => handleExport('clean')}>
          Export Clean Only
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  </>
) : (
  // Post-export state: show download buttons
  ...
)}
```

Update `handleExport` to accept an export type parameter:

```typescript
const handleExport = async (exportType: 'both' | 'track_changes' | 'clean') => {
  setExporting(true);
  const result = await doExport(authorName);
  setExporting(false);
  if (result) {
    setExported(true);
    setExportResult(result);
    setExportType(exportType);
  }
};
```

Add state: `const [exportType, setExportType] = useState<'both' | 'track_changes' | 'clean'>('both');`

Update the post-export download buttons to reflect what was requested:
- If `exportType === 'both'`: show both download buttons (current behavior)
- If `exportType === 'track_changes'`: auto-download the redline file immediately, show only the redline download button
- If `exportType === 'clean'`: auto-download the clean file immediately, show only the clean download button

For auto-download, call `download(exportType)` in a useEffect when `exported` becomes true and `exportType` is not 'both'. For 'both', show both buttons as before.

Actually, simpler: always show both buttons but auto-trigger download based on selection:

```typescript
useEffect(() => {
  if (!exported || !exportType) return;
  if (exportType === 'both') {
    download('track_changes');
    // Small delay to avoid browser blocking second download
    setTimeout(() => download('clean'), 500);
  } else {
    download(exportType);
  }
}, [exported, exportType, download]);
```

Then the post-export view just shows a success message with manual re-download buttons:
```tsx
<div className="flex w-full flex-col gap-2">
  <p className="text-sm text-green-700">Export complete. Downloads started.</p>
  <div className="flex gap-2 sm:justify-end">
    <Button size="sm" variant="outline" onClick={() => download("track_changes")}>
      <FileDown className="mr-1.5 h-3.5 w-3.5" />
      Re-download Redline
    </Button>
    <Button size="sm" variant="outline" onClick={() => download("clean")}>
      <FileDown className="mr-1.5 h-3.5 w-3.5" />
      Re-download Clean
    </Button>
  </div>
  <div className="flex items-center justify-between">
    <p className="text-xs text-muted-foreground">
      Session remains open. You can continue reviewing and re-export.
    </p>
    <Button variant="ghost" size="sm" onClick={() => onOpenChange(false)}>
      Close
    </Button>
  </div>
</div>
```

**G. Update the revision list rendering to use approvedRevisions from store:**

Replace the `preview.revisions` references with `approvedRevisions`:

```tsx
{approvedRevisions.length > 0 ? (
  <div className="max-h-64 overflow-y-auto rounded-md border">
    <Accordion type="multiple">
      {approvedRevisions.map((rev, i) => (
        <AccordionItem key={rev.para_id} value={`rev-${i}`}>
          <AccordionTrigger className="px-3 py-2 text-xs">
            <span className="flex items-center gap-2">
              <Badge variant="secondary" className="text-[10px]">
                {rev.section_ref}
              </Badge>
              <span className="line-clamp-1 text-left">
                {rev.rationale.slice(0, 80)}
                {rev.rationale.length > 80 ? "..." : ""}
              </span>
            </span>
          </AccordionTrigger>
          <AccordionContent className="px-3 pb-3">
            <div
              className="revision-diff text-sm leading-relaxed"
              dangerouslySetInnerHTML={{ __html: rev.diff_html }}
            />
          </AccordionContent>
        </AccordionItem>
      ))}
    </Accordion>
  </div>
) : (
  <p className="py-4 text-center text-sm text-muted-foreground">
    No approved revisions to export.
  </p>
)}
```

Remove the loading state render (Loader2 spinner) since there's no async fetch.

**H. Clean up imports:**

Remove `FinalizePreviewResponse` type import (no longer needed since we don't fetch preview).
Remove `useState` for `preview` and `loading`.
Add imports for DropdownMenu components and ChevronDown.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- finalize-dialog.tsx uses store revisions (no preview fetch on open)
- Dialog says "Approved" not "Accepted" in all user-facing text
- Stat boxes use center-aligned column layout with consistent number display
- Accordion shows only diff_html, NOT Original/Revised text
- Author name initializes from localStorage and persists changes
- Export button is a dropdown with three options: Both, Redline, Clean
- Auto-download triggers after export based on selection
- `npm run build` in frontend/ directory succeeds
  </verify>
  <done>
- Finalize dialog shows ALL approved revisions from store (single source of truth)
- "Approved Revisions" terminology throughout
- Stat boxes are cleanly aligned with centered icon/number/label
- Revision accordion shows diff only, no redundant text
- Author name persists in localStorage and autofills
- Export dropdown offers Redline, Clean, or Both options with auto-download
- Backend and frontend stay in sync via updated accept/unaccept endpoints
  </done>
</task>

</tasks>

<verification>
1. Accept a revision, close sheet, open Finalize -> revision appears in list
2. Reopen an accepted revision -> it disappears from Finalize dialog list
3. Re-accept the revision -> it reappears in Finalize dialog list
4. Accept a revision after inline editing -> Finalize shows the edited diff
5. Stat boxes show clean centered layout with numbers always visible
6. All text says "Approved" not "Accepted"
7. No Original/Revised text blocks in accordion - only diff
8. Author name field remembers value from last session (localStorage)
9. Export dropdown works: "Both" auto-downloads two files, "Redline" one file, "Clean" one file
10. `npx tsc --noEmit` passes
11. `npm run build` passes
</verification>

<success_criteria>
- UAT Test 5 gap closed: all approved revisions shown, correct terminology, clean layout, no redundant text, author autofill
- UAT Test 6 enhancement: export dropdown with three options
- Data consistency: store is single source of truth for revision list in dialog
- Backend sync: reopen() and accept-with-edits both sync to backend
</success_criteria>

<output>
After completion, create `.planning/phases/06-dialogs-finalization/06-05-SUMMARY.md`
</output>
