---
phase: 03-sidebar-risk-analysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/lib/store.ts
  - frontend/src/app/globals.css
  - frontend/src/hooks/use-analysis.ts
autonomous: true

must_haves:
  truths:
    - "Document paragraphs show visual state indicators (selected, has-risk, has-revision, flagged) via CSS"
    - "Analysis can be started and progress is polled every 1 second"
    - "Incremental risks arrive during analysis and appear in the store"
    - "Analysis completion stops polling and hydrates full results into store"
  artifacts:
    - path: "frontend/src/lib/store.ts"
      provides: "hoveredRiskId and focusedRiskId state + setters"
      contains: "hoveredRiskId"
    - path: "frontend/src/app/globals.css"
      provides: "CSS rules for .selected, .has-risk, .has-revision, .revision-accepted, .flagged, .risk-highlight"
      contains: "data-para-id"
    - path: "frontend/src/hooks/use-analysis.ts"
      provides: "useAnalysis hook with startAnalysis, polling, cleanup"
      exports: ["useAnalysis"]
  key_links:
    - from: "frontend/src/hooks/use-analysis.ts"
      to: "frontend/src/lib/api.ts"
      via: "getAnalysis and getAnalysisProgress calls"
      pattern: "getAnalysis|getAnalysisProgress"
    - from: "frontend/src/hooks/use-analysis.ts"
      to: "frontend/src/lib/store.ts"
      via: "setAnalysis, setAnalysisProgress, addIncrementalRisks actions"
      pattern: "setAnalysis|setAnalysisProgress|addIncrementalRisks"
---

<objective>
Add store state for risk hover/focus tracking, CSS rules for document paragraph visual states, and the analysis polling hook.

Purpose: This is the foundational infrastructure that all other Phase 3 plans depend on. The store additions enable sidebar-to-document coordination. The CSS rules make the existing class toggling in document-viewer.tsx actually visible. The analysis hook provides the data pipeline from backend analysis to frontend display.

Output: Modified store.ts with 4 new properties/actions, globals.css with ~50 lines of paragraph state CSS, and a new use-analysis.ts hook.
</objective>

<execution_context>
@C:\Users\david\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\david\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-sidebar-risk-analysis/03-RESEARCH.md

@frontend/src/lib/store.ts
@frontend/src/lib/types.ts
@frontend/src/lib/api.ts
@frontend/src/app/globals.css
@frontend/src/hooks/use-document.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add hover/focus state to store + paragraph CSS to globals.css</name>
  <files>frontend/src/lib/store.ts, frontend/src/app/globals.css</files>
  <action>
**Store changes (store.ts):**

Add to `UIState` interface:
- `hoveredRiskId: string | null` — which risk the user is hovering over in the sidebar
- `focusedRiskId: string | null` — which risk is "locked" by clicking (stays highlighted until clicked again)

Add to `initialUIState`:
- `hoveredRiskId: null`
- `focusedRiskId: null`

Add to `AppStore` interface actions:
- `setHoveredRiskId: (riskId: string | null) => void`
- `setFocusedRiskId: (riskId: string | null) => void`

Add action implementations:
- `setHoveredRiskId: (riskId) => set({ hoveredRiskId: riskId })`
- `setFocusedRiskId: (riskId) => set((state) => ({ focusedRiskId: state.focusedRiskId === riskId ? null : riskId }))` — toggle behavior: clicking same risk un-focuses it

**CSS changes (globals.css):**

Add inside the existing `@layer components` block, AFTER the `.document-container` and track-changes rules. These rules style the CSS classes that `document-viewer.tsx` already toggles via `updateParagraphStates()`:

```css
/* Document paragraph state styles */
.document-container [data-para-id] {
  cursor: pointer;
  border-radius: 4px;
  border: 2px solid transparent;
  transition: background-color 150ms, border-color 150ms, box-shadow 150ms;
}

.document-container [data-para-id]:hover {
  background-color: oklch(0.97 0.003 264 / 0.5);
}

.document-container [data-para-id].selected {
  background-color: oklch(0.95 0.02 264 / 0.3);
  border-color: oklch(0.546 0.215 264);
  box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.05);
}

.document-container [data-para-id].has-risk {
  box-shadow: inset 3px 0 0 oklch(0.705 0.213 47.604);
}

/* When both selected and has-risk, combine styles */
.document-container [data-para-id].selected.has-risk {
  background-color: oklch(0.95 0.02 264 / 0.3);
  border-color: oklch(0.546 0.215 264);
  box-shadow: inset 3px 0 0 oklch(0.705 0.213 47.604), 0 1px 3px 0 rgb(0 0 0 / 0.05);
}

.document-container [data-para-id].has-revision {
  background-color: oklch(0.98 0.01 27 / 0.3);
  border-color: oklch(0.85 0.1 27 / 0.5);
}

.document-container [data-para-id].revision-accepted {
  background-color: oklch(0.97 0.02 155 / 0.2);
  border-color: oklch(0.7 0.15 155 / 0.3);
}

.document-container [data-para-id].flagged {
  box-shadow: inset -3px 0 0 oklch(0.795 0.184 86.047);
}

/* Risk text highlighting - applied via TreeWalker in document-viewer */
.risk-highlight {
  background: linear-gradient(180deg, transparent 60%, oklch(0.85 0.1 27 / 0.5) 60%);
  padding: 0 2px;
}

.risk-highlight-active {
  background: oklch(0.9 0.08 27 / 0.4);
  outline: 2px solid oklch(0.577 0.245 27.325);
  outline-offset: 1px;
  border-radius: 2px;
}
```

These colors are derived from the existing design tokens:
- Selected (blue): uses --primary oklch value
- Has-risk (orange): uses --severity-high oklch value
- Has-revision (red-tint): uses --destructive oklch value
- Revision-accepted (green-tint): complementary green
- Flagged (yellow): uses --severity-medium oklch value
  </action>
  <verify>
Run `npx tsc --noEmit` from `frontend/` — no type errors. Visually inspect globals.css for valid CSS syntax. Confirm store.ts exports compile cleanly.
  </verify>
  <done>
store.ts has hoveredRiskId, focusedRiskId, setHoveredRiskId, setFocusedRiskId. globals.css has CSS rules for .selected, .has-risk, .has-revision, .revision-accepted, .flagged, .risk-highlight, .risk-highlight-active inside @layer components.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create use-analysis.ts polling hook</name>
  <files>frontend/src/hooks/use-analysis.ts</files>
  <action>
Create `frontend/src/hooks/use-analysis.ts` following the pattern from `use-document.ts` (same directory). This hook:

1. **Exports:** `useAnalysis(sessionId: string | null)` returning `{ startAnalysis, isAnalyzing }`

2. **Behavior:**
   - `startAnalysis()`:
     - Guards: if no sessionId or already completed (`completedRef`), return early
     - Sets `isAnalyzing` local state to true
     - Calls `setAnalysisProgress({ analysisStatus: 'analyzing', analysisStage: 'initial_analysis', analysisPercent: 0, stageDisplay: 'Starting analysis...' })`
     - Starts polling via `setInterval` at 1000ms
     - Simultaneously calls `getAnalysis(sessionId)` which blocks until complete

   - **Polling callback** (inside setInterval):
     - Calls `getAnalysisProgress(sessionId, { includeRisks: true, lastApiCallId: lastApiCallIdRef.current })`
     - Updates `lastApiCallIdRef` from `progress.api_calls` (max id + 1)
     - Calls `setAnalysisProgress()` with status, stage, percent, stageDisplay
     - If `progress.incremental_risks?.length`, calls `addIncrementalRisks()`
     - If `progress.status === 'complete'`, calls `stopPolling()`
     - Wraps in try/catch, silently continues on error

   - **When `getAnalysis()` resolves:**
     - Calls `stopPolling()`
     - Sets `completedRef.current = true`
     - Calls `setAnalysis()` with full results: `risks: result.risk_inventory, conceptMap: result.concept_map, riskMap: result.risk_map, summary: result.summary, analysisStatus: 'complete', analysisStage: 'complete', analysisPercent: 100, stageDisplay: 'Analysis complete'`

   - **On error from `getAnalysis()`:**
     - Calls `stopPolling()`
     - Resets progress to not_started
     - Shows toast error via `toast.error()`

   - **On finally:** Sets `isAnalyzing` to false

3. **Cleanup:**
   - `stopPolling()` helper clears interval and nulls the ref
   - `useEffect` cleanup calls `stopPolling()` on unmount

4. **Race condition prevention:**
   - Use `completedRef = useRef(false)` to track whether full results received
   - Use `lastApiCallIdRef = useRef(0)` for polling cursor (avoids stale closure)
   - Use `intervalRef = useRef<ReturnType<typeof setInterval> | null>(null)` for interval handle

5. **Store selectors:** Use individual selectors (not destructuring) to minimize re-renders:
   ```typescript
   const setAnalysis = useAppStore((s) => s.setAnalysis);
   const setAnalysisProgress = useAppStore((s) => s.setAnalysisProgress);
   const addIncrementalRisks = useAppStore((s) => s.addIncrementalRisks);
   ```

6. **Imports:** `useCallback, useEffect, useRef, useState` from react; `useAppStore` from store; `getAnalysis, getAnalysisProgress` from api; `toast` from sonner.

Add `"use client";` directive at top of file.

Reference the code example in 03-RESEARCH.md for the exact implementation pattern. The research has a complete working example.
  </action>
  <verify>
Run `npx tsc --noEmit` from `frontend/` — no type errors. Read the file and verify: (1) interval cleanup on unmount, (2) completedRef guards against double-completion, (3) lastApiCallIdRef prevents stale closure, (4) error handling resets state.
  </verify>
  <done>
use-analysis.ts exports useAnalysis hook. Hook starts analysis, polls at 1s intervals, adds incremental risks to store, handles completion with full hydration, cleans up interval on unmount, prevents race conditions via refs.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in frontend/ with zero errors
2. `npm run build` passes in frontend/
3. store.ts has hoveredRiskId, focusedRiskId with setters
4. globals.css has .selected, .has-risk, .has-revision, .revision-accepted, .flagged CSS rules
5. use-analysis.ts exports useAnalysis with startAnalysis function
</verification>

<success_criteria>
- Store compiles with 4 new properties (hoveredRiskId, focusedRiskId, setHoveredRiskId, setFocusedRiskId)
- CSS rules exist for all 5 paragraph state classes + 2 risk highlight classes
- use-analysis.ts hook compiles and follows the polling pattern from research
- No regressions in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/03-sidebar-risk-analysis/03-01-SUMMARY.md`
</output>
