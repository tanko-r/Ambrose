---
phase: 03-sidebar-risk-analysis
plan: 04
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - frontend/src/components/review/document-viewer.tsx
  - frontend/src/components/review/risk-accordion.tsx
  - frontend/src/components/review/definitions-tab.tsx
  - frontend/src/components/review/related-clauses-tab.tsx
  - frontend/src/components/review/flags-tab.tsx
  - frontend/src/components/review/sidebar.tsx
autonomous: true

must_haves:
  truths:
    - "Hovering over a risk card highlights the risk's highlight_text in the document viewer"
    - "Clicking a risk card locks the highlight until clicked again (focus toggle)"
    - "Definitions tab shows defined terms that appear in the selected paragraph"
    - "Related clauses tab fetches and displays precedent clauses for the selected paragraph"
    - "Flags tab shows a stub placeholder for Phase 6"
  artifacts:
    - path: "frontend/src/components/review/document-viewer.tsx"
      provides: "Risk text highlighting via TreeWalker based on store hoveredRiskId/focusedRiskId"
      contains: "hoveredRiskId"
    - path: "frontend/src/components/review/risk-accordion.tsx"
      provides: "Updated with real store connections for hover/focus"
      contains: "setHoveredRiskId"
    - path: "frontend/src/components/review/definitions-tab.tsx"
      provides: "Definitions tab component showing defined terms relevant to selected paragraph"
      exports: ["DefinitionsTab"]
    - path: "frontend/src/components/review/related-clauses-tab.tsx"
      provides: "Related clauses tab with API fetching and caching"
      exports: ["RelatedClausesTab"]
    - path: "frontend/src/components/review/flags-tab.tsx"
      provides: "Flags tab placeholder for Phase 6"
      exports: ["FlagsTab"]
    - path: "frontend/src/components/review/sidebar.tsx"
      provides: "Sidebar using new tab components"
      contains: "DefinitionsTab"
  key_links:
    - from: "frontend/src/components/review/risk-accordion.tsx"
      to: "frontend/src/lib/store.ts"
      via: "setHoveredRiskId and setFocusedRiskId store actions"
      pattern: "setHoveredRiskId|setFocusedRiskId"
    - from: "frontend/src/components/review/document-viewer.tsx"
      to: "frontend/src/lib/store.ts"
      via: "reads hoveredRiskId, focusedRiskId, risks to find highlight_text"
      pattern: "hoveredRiskId|focusedRiskId"
    - from: "frontend/src/components/review/related-clauses-tab.tsx"
      to: "frontend/src/lib/api.ts"
      via: "getRelatedClauses API call"
      pattern: "getRelatedClauses"
---

<objective>
Wire risk hover/focus highlighting between sidebar and document, and build the remaining sidebar tabs (definitions, related clauses, flags).

Purpose: This is the "last mile" integration that makes the sidebar truly interactive. Without highlighting, users can't see which text a risk refers to. Without the definitions and related clauses tabs, the sidebar is incomplete. This plan connects all the pieces built in Plans 01 and 02.

Output: Updated document-viewer.tsx with highlight logic, updated risk-accordion.tsx with store wiring, and three new tab components wired into sidebar.tsx.
</objective>

<execution_context>
@C:\Users\david\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\david\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-sidebar-risk-analysis/03-RESEARCH.md
@.planning/phases/03-sidebar-risk-analysis/03-01-SUMMARY.md
@.planning/phases/03-sidebar-risk-analysis/03-02-SUMMARY.md

@frontend/src/components/review/document-viewer.tsx
@frontend/src/components/review/risk-accordion.tsx
@frontend/src/components/review/sidebar.tsx
@frontend/src/lib/store.ts
@frontend/src/lib/types.ts
@frontend/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add risk text highlighting to document-viewer.tsx and wire risk-accordion.tsx to store</name>
  <files>frontend/src/components/review/document-viewer.tsx, frontend/src/components/review/risk-accordion.tsx</files>
  <action>
**document-viewer.tsx changes:**

1. **Add store selectors** for highlight state:
   ```typescript
   const hoveredRiskId = useAppStore((s) => s.hoveredRiskId);
   const focusedRiskId = useAppStore((s) => s.focusedRiskId);
   ```

2. **Create `highlightRiskText` function** (inside component or as a useCallback):
   This function finds the risk's `highlight_text` in the document and wraps it with a `<mark>` element.

   ```typescript
   const highlightRiskText = useCallback(() => {
     const container = containerRef.current;
     if (!container) return;

     // First, remove all existing risk highlights
     container.querySelectorAll('.risk-highlight, .risk-highlight-active').forEach(mark => {
       const parent = mark.parentNode;
       if (parent) {
         parent.replaceChild(document.createTextNode(mark.textContent || ''), mark);
         parent.normalize(); // merge adjacent text nodes
       }
     });

     // Determine which risk to highlight (focused takes priority over hovered)
     const activeRiskId = focusedRiskId || hoveredRiskId;
     if (!activeRiskId) return;

     // Find the risk object to get highlight_text and para_id
     const risk = risks.find(r => r.risk_id === activeRiskId);
     if (!risk?.highlight_text) return;

     // Find the paragraph element
     const paraEl = container.querySelector(`[data-para-id="${risk.para_id}"]`);
     if (!paraEl) return;

     // Use TreeWalker to find text nodes containing the highlight_text
     const walker = document.createTreeWalker(paraEl, NodeFilter.SHOW_TEXT);
     const textContent = risk.highlight_text;
     let node: Text | null;
     let found = false;

     while ((node = walker.nextNode() as Text | null)) {
       const idx = node.textContent?.indexOf(textContent) ?? -1;
       if (idx !== -1 && node.textContent) {
         // Split text node and wrap the matching part
         const before = node.textContent.substring(0, idx);
         const match = node.textContent.substring(idx, idx + textContent.length);
         const after = node.textContent.substring(idx + textContent.length);

         const mark = document.createElement('mark');
         mark.className = focusedRiskId === activeRiskId ? 'risk-highlight-active' : 'risk-highlight';
         mark.textContent = match;

         const parent = node.parentNode!;
         if (before) parent.insertBefore(document.createTextNode(before), node);
         parent.insertBefore(mark, node);
         if (after) parent.insertBefore(document.createTextNode(after), node);
         parent.removeChild(node);

         found = true;
         break; // Only highlight first match
       }
     }

     // Fallback: try matching first 50 chars if full text not found
     if (!found && textContent.length > 50) {
       const shortText = textContent.substring(0, 50);
       const walker2 = document.createTreeWalker(paraEl, NodeFilter.SHOW_TEXT);
       while ((node = walker2.nextNode() as Text | null)) {
         const idx = node.textContent?.indexOf(shortText) ?? -1;
         if (idx !== -1 && node.textContent) {
           const mark = document.createElement('mark');
           mark.className = focusedRiskId === activeRiskId ? 'risk-highlight-active' : 'risk-highlight';
           // Highlight from match start to end of text node (approximate)
           const before = node.textContent.substring(0, idx);
           const matchText = node.textContent.substring(idx);
           mark.textContent = matchText;

           const parent = node.parentNode!;
           if (before) parent.insertBefore(document.createTextNode(before), node);
           parent.insertBefore(mark, node);
           parent.removeChild(node);
           break;
         }
       }
     }

     // Scroll highlighted text into view if focused (not just hovered)
     if (focusedRiskId === activeRiskId) {
       const highlighted = container.querySelector('.risk-highlight-active');
       if (highlighted) {
         highlighted.scrollIntoView({ behavior: 'smooth', block: 'center' });
       }
     }
   }, [hoveredRiskId, focusedRiskId, risks]);
   ```

3. **Add useEffect** to trigger highlighting when hover/focus changes:
   ```typescript
   useEffect(() => {
     if (documentHtml) {
       requestAnimationFrame(() => highlightRiskText());
     }
   }, [documentHtml, highlightRiskText]);
   ```

**risk-accordion.tsx changes:**

Replace the no-op hover/focus handlers with real store connections:

1. **Add store imports:**
   ```typescript
   const setHoveredRiskId = useAppStore((s) => s.setHoveredRiskId);
   const setFocusedRiskId = useAppStore((s) => s.setFocusedRiskId);
   ```

2. **Replace handlers:**
   ```typescript
   const handleHover = useCallback((riskId: string | null) => {
     setHoveredRiskId(riskId);
   }, [setHoveredRiskId]);

   const handleFocus = useCallback((riskId: string) => {
     setFocusedRiskId(riskId);
   }, [setFocusedRiskId]);
   ```

3. **Add cleanup on unmount or paraId change:**
   ```typescript
   useEffect(() => {
     return () => {
       setHoveredRiskId(null);
       // Don't clear focusedRiskId on unmount — user may want to keep it
     };
   }, [paraId, setHoveredRiskId]);
   ```

4. **Add import for useCallback, useEffect** from React if not already imported.
5. **Add import for useAppStore** from store if not already imported.
  </action>
  <verify>
Run `npx tsc --noEmit` from `frontend/` — no type errors. Read document-viewer.tsx and verify: (1) reads hoveredRiskId and focusedRiskId from store, (2) highlightRiskText uses TreeWalker, (3) cleans up old highlights before applying new ones, (4) has fallback for partial text match. Read risk-accordion.tsx and verify: (1) calls setHoveredRiskId and setFocusedRiskId from store, (2) cleans up on paraId change.
  </verify>
  <done>
Hovering a risk card in the sidebar highlights the corresponding text in the document viewer. Clicking a risk locks the highlight. Document-viewer uses TreeWalker to find and wrap matching text with CSS highlight classes. risk-accordion wired to store for hover/focus coordination.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create definitions-tab, related-clauses-tab, flags-tab and wire into sidebar</name>
  <files>frontend/src/components/review/definitions-tab.tsx, frontend/src/components/review/related-clauses-tab.tsx, frontend/src/components/review/flags-tab.tsx, frontend/src/components/review/sidebar.tsx</files>
  <action>
**definitions-tab.tsx:**

```
"use client";
```

Props: `{ paraId: string | null }`

Implementation:
- Read `definedTerms` and `paragraphs` from store
- Find the selected paragraph text: `paragraphs.find(p => p.id === paraId)?.text`
- Filter defined terms to show:
  1. Terms whose `para_id` matches the selected paragraph (terms defined in this paragraph)
  2. Terms whose `term` appears in the selected paragraph's text (case-insensitive search)
  - Deduplicate by term name
  - Sort: terms defined in this paragraph first, then alphabetically

- Render a list of term cards:
  ```tsx
  <div className="space-y-2">
    {filteredTerms.map(term => (
      <div key={term.term} className="rounded-lg border p-3">
        <div className="flex items-start justify-between gap-2">
          <span className="text-sm font-semibold text-primary">{term.term}</span>
          <Badge variant="secondary" className="text-[10px] shrink-0">{term.section_ref}</Badge>
        </div>
        <p className="mt-1 text-xs leading-relaxed text-muted-foreground">{term.definition}</p>
      </div>
    ))}
  </div>
  ```

- Empty state: "No defined terms found in this clause."
- If no paraId: "Select a clause to see relevant definitions."

Export: `DefinitionsTab`

---

**related-clauses-tab.tsx:**

```
"use client";
```

Props: `{ sessionId: string | null; paraId: string | null }`

Implementation:
- Local state: `relatedClauses: RelatedClause[]`, `loading: boolean`, `error: string | null`
- Local cache: `useRef<Map<string, RelatedClause[]>>(new Map())` — keyed by paraId
- Check if precedent exists: `hasPrecedent` from store

- `useEffect` triggered by `paraId` changes:
  - If no paraId or no hasPrecedent: clear clauses, return
  - If cache has entry for paraId: use cached data, skip fetch
  - Otherwise: set loading, call `getRelatedClauses(sessionId!, paraId)`, store results in state and cache
  - Catch errors: set error state, show toast

- Render:
  - If no hasPrecedent: "No precedent document uploaded. Upload a precedent in the intake form to see related clauses."
  - If loading: Skeleton loader (2-3 skeleton cards)
  - If error: error message
  - If no results: "No related clauses found in precedent document."
  - Otherwise: list of related clause cards:
    ```tsx
    <div className="space-y-2">
      {relatedClauses.map(clause => (
        <div key={clause.para_id} className="rounded-lg border p-3">
          <div className="flex items-center gap-2 mb-1">
            <Badge variant="secondary" className="text-[10px]">{clause.section_ref}</Badge>
            <span className="text-[10px] text-muted-foreground">
              {Math.round(clause.similarity * 100)}% match
            </span>
          </div>
          <p className="text-xs leading-relaxed text-muted-foreground line-clamp-3">{clause.text}</p>
        </div>
      ))}
    </div>
    ```

Import types: `RelatedClause` from types.ts, `getRelatedClauses` from api.ts, `Skeleton` from shadcn, `Badge` from shadcn, `toast` from sonner.

Export: `RelatedClausesTab`

---

**flags-tab.tsx:**

```
"use client";
```

Props: `{ paraId: string | null }`

Implementation:
- Read `flags` from store
- Filter flags for the selected paraId
- If no paraId: "Select a clause to see flags."
- If no flags for this paragraph: "No flags on this clause. Use the Flag button to mark clauses for client or attorney review."
- If flags exist: show flag cards with note, type badge (client/attorney), timestamp
- Add a note: "Full flagging UI available in Phase 6." (temporary placeholder text)

Export: `FlagsTab`

---

**sidebar.tsx changes:**

1. **Add imports:**
   ```typescript
   import { DefinitionsTab } from "./definitions-tab";
   import { RelatedClausesTab } from "./related-clauses-tab";
   import { FlagsTab } from "./flags-tab";
   ```

2. **Get sessionId from store:**
   ```typescript
   const sessionId = useAppStore((s) => s.sessionId);
   ```

3. **Replace EmptyState placeholders** in the content section:
   - `activeTab === "related"` -> `<RelatedClausesTab sessionId={sessionId} paraId={selectedParaId} />`
   - `activeTab === "definitions"` -> `<DefinitionsTab paraId={selectedParaId} />`
   - `activeTab === "flags"` -> `<FlagsTab paraId={selectedParaId} />`

4. **Keep the guard** for no selectedParaId at the top of the content section (before any tab content).
  </action>
  <verify>
Run `npx tsc --noEmit` from `frontend/` — no type errors. Run `npm run build` from `frontend/` — build succeeds. Read each new file and verify: (1) definitions-tab filters terms by paragraph text, (2) related-clauses-tab caches results and only fetches when tab is active and paraId changes, (3) flags-tab shows existing flags or placeholder, (4) sidebar.tsx imports and renders all three tabs.
  </verify>
  <done>
Definitions tab shows defined terms relevant to selected paragraph. Related clauses tab fetches from API with caching. Flags tab shows existing flags with placeholder for Phase 6. Sidebar renders all three real tab components instead of placeholder text.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in frontend/
2. `npm run build` passes in frontend/
3. Hovering a risk in sidebar highlights text in document viewer
4. Clicking a risk locks the highlight (click again to unlock)
5. Definitions tab shows terms found in selected paragraph's text
6. Related clauses tab fetches data (only when precedent exists) with loading state
7. Flags tab shows existing flags or appropriate empty state
8. All sidebar tabs render real components, no more "coming in Phase X" placeholders (except flags which shows a note about Phase 6)
</verification>

<success_criteria>
- Risk hover highlighting works: hover risk card -> text highlighted in document with underline effect
- Risk focus highlighting works: click risk card -> text highlighted with stronger outline, scrolls into view
- Leaving a risk card clears hover highlight; clicking same risk again clears focus highlight
- Definitions tab filters and displays terms relevant to the current paragraph
- Related clauses tab fetches from API, caches results, shows loading skeleton
- No duplicate API calls for same paraId in related clauses tab
- All tabs in sidebar are functional (risks, related, definitions, flags)
</success_criteria>

<output>
After completion, create `.planning/phases/03-sidebar-risk-analysis/03-04-SUMMARY.md`
</output>
