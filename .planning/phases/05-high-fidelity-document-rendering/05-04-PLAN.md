---
phase: 05-high-fidelity-document-rendering
plan: 04
type: execute
wave: 4
depends_on: ["05-02", "05-03"]
files_modified:
  - app/static/js/document.js
  - app/static/js/precedent.js
  - app/static/index.html
  - app/static/css/main.css
  - app/services/pdf_service.py
autonomous: true

must_haves:
  truths:
    - "Loading spinner shows while PDF is being generated"
    - "Error message displays if PDF conversion fails"
    - "Fallback rendering activates when PDF unavailable"
    - "LibreOffice missing shows helpful error message"
  artifacts:
    - path: "app/static/index.html"
      provides: "docx-preview.js fallback library"
      contains: "docx-preview"
    - path: "app/static/js/document.js"
      provides: "Fallback rendering logic"
      contains: "docx.renderAsync"
    - path: "app/services/pdf_service.py"
      provides: "LibreOffice detection"
      contains: "check_libreoffice_available"
  key_links:
    - from: "app/static/js/document.js"
      to: "docx-preview"
      via: "fallback when PDF fails"
      pattern: "docx\\.renderAsync"
---

<objective>
Add robust fallback rendering and proper loading/error states.

Purpose: Ensure the app works gracefully when PDF conversion fails (LibreOffice not installed, conversion timeout, corrupt file) by providing docx-preview.js as a JavaScript-only fallback. Add proper loading states to improve user experience during the 2-3 second PDF conversion.

Output: Polished loading states, clear error messages, and JavaScript-only fallback rendering when PDF is unavailable.
</objective>

<execution_context>
@C:\Users\david\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\david\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-high-fidelity-document-rendering/05-RESEARCH.md
@.planning/phases/05-high-fidelity-document-rendering/05-02-SUMMARY.md
@.planning/phases/05-high-fidelity-document-rendering/05-03-SUMMARY.md

@app/static/js/document.js
@app/static/js/precedent.js
@app/services/pdf_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LibreOffice availability check endpoint</name>
  <files>app/services/pdf_service.py, app/api/routes.py</files>
  <action>
**In pdf_service.py:**

Add a function to check if LibreOffice is available:

```python
import shutil

def check_libreoffice_available():
    """
    Check if LibreOffice is installed and accessible.

    Returns:
        dict with 'available' (bool), 'path' (str or None), 'error' (str or None)
    """
    try:
        exec_path = libreoffice_exec()

        # Verify the path exists
        if not Path(exec_path).exists():
            return {
                'available': False,
                'path': None,
                'error': f'LibreOffice not found at expected path: {exec_path}'
            }

        return {
            'available': True,
            'path': exec_path,
            'error': None
        }
    except Exception as e:
        return {
            'available': False,
            'path': None,
            'error': str(e)
        }
```

Update libreoffice_exec() to try multiple paths on Windows:

```python
def libreoffice_exec():
    """Return LibreOffice executable path based on platform."""
    if sys.platform == 'win32':
        # Try common installation paths
        paths = [
            r'C:\Program Files\LibreOffice\program\soffice.exe',
            r'C:\Program Files (x86)\LibreOffice\program\soffice.exe',
            os.path.expanduser(r'~\AppData\Local\Programs\LibreOffice\program\soffice.exe'),
        ]
        for path in paths:
            if Path(path).exists():
                return path

        # Try to find via PATH
        soffice_in_path = shutil.which('soffice')
        if soffice_in_path:
            return soffice_in_path

        # Return default and let caller handle if not found
        return paths[0]

    elif sys.platform == 'darwin':
        return '/Applications/LibreOffice.app/Contents/MacOS/soffice'
    else:
        return shutil.which('libreoffice') or 'libreoffice'
```

**In routes.py:**

Add a status endpoint to check rendering capabilities:

```python
@api_bp.route('/render/status', methods=['GET'])
def get_render_status():
    """
    Check rendering capabilities (PDF conversion availability).

    Returns status of PDF rendering system for frontend to decide
    whether to use PDF or fallback rendering.
    """
    from app.services.pdf_service import check_libreoffice_available

    lo_status = check_libreoffice_available()

    return jsonify({
        'pdf_available': lo_status['available'],
        'libreoffice_path': lo_status['path'],
        'error': lo_status['error'],
        'fallback_available': True,  # docx-preview.js is always available
        'recommendation': 'pdf' if lo_status['available'] else 'fallback'
    })
```
  </action>
  <verify>
Test the endpoint:
```bash
curl http://localhost:5000/api/render/status
```
Should return JSON with pdf_available: true if LibreOffice is installed.
  </verify>
  <done>
LibreOffice availability check exists and is exposed via API. Multiple installation paths are tried on Windows.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add docx-preview.js fallback library and integration</name>
  <files>app/static/index.html, app/static/js/document.js</files>
  <action>
**In index.html:**

Add docx-preview.js library (after PDF.js includes):

```html
<!-- docx-preview.js for fallback rendering -->
<script src="https://unpkg.com/docx-preview@0.3.7/dist/docx-preview.min.js"></script>
```

**In document.js:**

Add fallback rendering using docx-preview when PDF fails:

1. **Add render mode tracking:**
```javascript
// Render mode: 'pdf', 'docx-preview', 'text'
let documentRenderMode = 'text';
```

2. **Add docx-preview fallback function:**
```javascript
async function renderDocumentWithDocxPreview() {
    const container = document.getElementById('document-text-content');
    if (!container) return false;

    // Need to fetch the actual DOCX file
    const docxUrl = `/api/document/${AppState.sessionId}/docx`;

    try {
        // Show loading state
        container.innerHTML = `
            <div class="docx-preview-loading">
                <div class="pdf-loading-spinner"></div>
                <p>Loading document preview...</p>
            </div>
        `;

        // Fetch DOCX blob
        const response = await fetch(docxUrl);
        if (!response.ok) {
            throw new Error('Failed to fetch document');
        }
        const docxBlob = await response.blob();

        // Clear container
        container.innerHTML = '';

        // Render using docx-preview
        await docx.renderAsync(docxBlob, container, null, {
            className: 'docx-preview-content',
            inWrapper: true,
            ignoreWidth: false,
            ignoreHeight: false,
            ignoreFonts: false,
            breakPages: true,
            renderHeaders: true,
            renderFooters: true,
            experimental: false,
            debug: false
        });

        // Add click handlers to paragraphs
        setupDocxPreviewClickHandlers(container);

        documentRenderMode = 'docx-preview';
        return true;

    } catch (error) {
        console.error('docx-preview rendering failed:', error);
        return false;
    }
}

function setupDocxPreviewClickHandlers(container) {
    // Map rendered paragraphs to document paragraph IDs
    const renderedParas = container.querySelectorAll('p');
    const docParas = AppState.document.content.filter(item => item.type === 'paragraph');

    renderedParas.forEach((el, index) => {
        if (docParas[index]) {
            el.dataset.paraId = docParas[index].id;
            el.classList.add('docx-preview-para');
            el.onclick = () => selectParagraph(docParas[index].id);
        }
    });
}
```

3. **Add DOCX serving endpoint (in routes.py):**
```python
@api_bp.route('/document/<session_id>/docx', methods=['GET'])
def serve_document_docx(session_id):
    """Serve original DOCX file for client-side rendering fallback."""
    session = get_session(session_id)
    if not session:
        return jsonify({'error': 'Session not found'}), 404

    target_path = session.get('target_path')
    if not target_path or not Path(target_path).exists():
        return jsonify({'error': 'Document not found'}), 404

    return send_file(
        target_path,
        mimetype='application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        as_attachment=False
    )
```

4. **Update loadDocument() with fallback chain:**
```javascript
async function loadDocument() {
    const result = await api(`/document/${AppState.sessionId}`);
    AppState.document = result;
    AppState.flags = result.flags || [];
    AppState.revisions = result.revisions || {};

    // Check render capabilities
    let renderStatus;
    try {
        renderStatus = await api('/render/status');
    } catch (e) {
        renderStatus = { pdf_available: false };
    }

    const pdfContainer = document.getElementById('document-pdf-content');
    const textContainer = document.getElementById('document-text-content');

    // Render chain: PDF -> docx-preview -> text
    if (renderStatus.pdf_available && pdfContainer && typeof pdfjsLib !== 'undefined') {
        // Try PDF rendering
        pdfContainer.classList.remove('hidden');
        textContainer.classList.add('hidden');

        try {
            await renderDocumentAsPdf();
            documentRenderMode = 'pdf';
        } catch (pdfError) {
            console.warn('PDF rendering failed, trying docx-preview:', pdfError);
            pdfContainer.classList.add('hidden');
            textContainer.classList.remove('hidden');

            // Try docx-preview
            if (typeof docx !== 'undefined') {
                const success = await renderDocumentWithDocxPreview();
                if (!success) {
                    renderDocument();  // Final fallback to text
                    documentRenderMode = 'text';
                }
            } else {
                renderDocument();
                documentRenderMode = 'text';
            }
        }
    } else if (typeof docx !== 'undefined') {
        // PDF not available, try docx-preview
        pdfContainer?.classList.add('hidden');
        textContainer?.classList.remove('hidden');
        const success = await renderDocumentWithDocxPreview();
        if (!success) {
            renderDocument();
            documentRenderMode = 'text';
        }
    } else {
        // Final fallback to text rendering
        pdfContainer?.classList.add('hidden');
        textContainer?.classList.remove('hidden');
        renderDocument();
        documentRenderMode = 'text';
    }

    // Update navigation panel
    if (typeof updateNavPanel === 'function') {
        updateNavPanel();
    }
}
```
  </action>
  <verify>
1. Temporarily rename LibreOffice executable
2. Load a document - should fall back to docx-preview rendering
3. Verify document displays (may have some formatting differences)
4. Click on paragraphs - sidebar should update
5. Restore LibreOffice - verify PDF rendering resumes
  </verify>
  <done>
docx-preview.js fallback is integrated. Render chain tries PDF first, then docx-preview, then text. All modes support paragraph selection.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add loading states and error handling UI</name>
  <files>app/static/css/main.css, app/static/js/document.js, app/static/js/precedent.js</files>
  <action>
**In main.css:**

Add loading and error state styles:

```css
/* Loading States */
.render-loading {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 80px 20px;
    color: #666;
    min-height: 300px;
}

.render-loading-spinner {
    width: 48px;
    height: 48px;
    border: 4px solid #e5e7eb;
    border-top-color: #3b82f6;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 16px;
}

.render-loading-text {
    font-size: 15px;
    color: #6b7280;
}

.render-loading-subtext {
    font-size: 13px;
    color: #9ca3af;
    margin-top: 8px;
}

/* Error States */
.render-error {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 60px 20px;
    text-align: center;
    min-height: 300px;
}

.render-error-icon {
    width: 48px;
    height: 48px;
    color: #ef4444;
    margin-bottom: 16px;
}

.render-error-title {
    font-size: 16px;
    font-weight: 600;
    color: #374151;
    margin-bottom: 8px;
}

.render-error-message {
    font-size: 14px;
    color: #6b7280;
    max-width: 400px;
    margin-bottom: 16px;
}

.render-error-action {
    padding: 8px 16px;
    background: #3b82f6;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
}

.render-error-action:hover {
    background: #2563eb;
}

/* Render mode indicator */
.render-mode-indicator {
    position: absolute;
    top: 8px;
    right: 8px;
    padding: 4px 8px;
    background: rgba(0,0,0,0.6);
    color: white;
    font-size: 11px;
    border-radius: 4px;
    z-index: 10;
    opacity: 0;
    transition: opacity 0.2s;
}

.document-content:hover .render-mode-indicator {
    opacity: 1;
}

/* docx-preview specific styles */
.docx-preview-content {
    padding: 20px;
}

.docx-preview-para {
    cursor: pointer;
    transition: background-color 0.15s;
    border-radius: 2px;
    padding: 2px 4px;
    margin: -2px -4px;
}

.docx-preview-para:hover {
    background-color: rgba(59, 130, 246, 0.08);
}

.docx-preview-para.selected {
    background-color: rgba(59, 130, 246, 0.15);
    outline: 2px solid #3b82f6;
}
```

**In document.js:**

Add functions to show loading and error states:

```javascript
function showDocumentLoading(message = 'Loading document...', subtext = '') {
    const container = document.getElementById('document-content');
    if (!container) return;

    container.innerHTML = `
        <div class="render-loading">
            <div class="render-loading-spinner"></div>
            <div class="render-loading-text">${escapeHtml(message)}</div>
            ${subtext ? `<div class="render-loading-subtext">${escapeHtml(subtext)}</div>` : ''}
        </div>
    `;
}

function showDocumentError(title, message, actionText = null, actionFn = null) {
    const container = document.getElementById('document-content');
    if (!container) return;

    let actionHtml = '';
    if (actionText && actionFn) {
        window._documentErrorAction = actionFn;
        actionHtml = `<button class="render-error-action" onclick="window._documentErrorAction()">${escapeHtml(actionText)}</button>`;
    }

    container.innerHTML = `
        <div class="render-error">
            <svg class="render-error-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                      d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
            <div class="render-error-title">${escapeHtml(title)}</div>
            <div class="render-error-message">${escapeHtml(message)}</div>
            ${actionHtml}
        </div>
    `;
}

function addRenderModeIndicator(mode) {
    const container = document.getElementById('document-content');
    if (!container) return;

    // Remove existing indicator
    const existing = container.querySelector('.render-mode-indicator');
    if (existing) existing.remove();

    const modeLabels = {
        'pdf': 'PDF View',
        'docx-preview': 'Preview Mode',
        'text': 'Text Mode'
    };

    const indicator = document.createElement('div');
    indicator.className = 'render-mode-indicator';
    indicator.textContent = modeLabels[mode] || mode;
    container.appendChild(indicator);
}

// Export
window.showDocumentLoading = showDocumentLoading;
window.showDocumentError = showDocumentError;
window.addRenderModeIndicator = addRenderModeIndicator;
```

Update renderDocumentAsPdf() to use the loading state:
```javascript
// At the start of renderDocumentAsPdf():
showDocumentLoading('Generating PDF preview...', 'This may take a few seconds for large documents');
```

Add error handling with helpful messages:
```javascript
// In the catch block of renderDocumentAsPdf():
catch (error) {
    console.error('PDF rendering failed:', error);

    // Check if it's a LibreOffice issue
    if (error.message.includes('LibreOffice') || error.message.includes('conversion')) {
        showDocumentError(
            'PDF Preview Unavailable',
            'LibreOffice is required for high-fidelity preview. The document will be shown in basic mode.',
            'Use Basic View',
            showTextFallback
        );
    } else {
        showTextFallback();
    }
}
```

After successful render, add the mode indicator:
```javascript
// At the end of successful renderDocumentAsPdf():
addRenderModeIndicator('pdf');
```

**In precedent.js:**

Add similar loading state for precedent panel:
```javascript
function showPrecedentLoading(message = 'Loading precedent...') {
    const contentEl = document.getElementById('precedent-content');
    if (!contentEl) return;

    contentEl.innerHTML = `
        <div class="render-loading">
            <div class="render-loading-spinner"></div>
            <div class="render-loading-text">${escapeHtml(message)}</div>
        </div>
    `;
}

// Use at start of renderPrecedentAsPdf():
showPrecedentLoading('Generating PDF preview...');
```
  </action>
  <verify>
1. Load a document - verify loading spinner appears
2. Loading text should say "Generating PDF preview..."
3. After load, hover over document to see render mode indicator
4. If PDF fails, verify error message is clear and helpful
5. Verify "Use Basic View" button works
  </verify>
  <done>
Loading states show during PDF generation. Error messages are clear and actionable. Render mode indicator shows which rendering engine is active.
  </done>
</task>

</tasks>

<verification>
- [ ] LibreOffice availability check works
- [ ] /render/status endpoint returns correct info
- [ ] docx-preview.js library loads from CDN
- [ ] Fallback to docx-preview works when PDF unavailable
- [ ] Fallback to text works when both PDF and docx-preview fail
- [ ] Loading spinner displays during PDF generation
- [ ] Error messages are clear when conversion fails
- [ ] Render mode indicator shows current mode
- [ ] All render modes support paragraph selection
</verification>

<success_criteria>
1. App works even if LibreOffice is not installed (uses docx-preview fallback)
2. Loading state shows during PDF conversion (no blank screen)
3. Error messages explain what's wrong and how to fix it
4. User can manually switch to basic text view if needed
5. Render mode indicator shows which engine is active (PDF/Preview/Text)
6. All three render modes maintain full functionality (selection, sidebar, risks)
</success_criteria>

<output>
After completion, create `.planning/phases/05-high-fidelity-document-rendering/05-04-SUMMARY.md`
</output>
