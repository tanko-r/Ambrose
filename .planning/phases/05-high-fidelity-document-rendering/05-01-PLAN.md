---
phase: 05-high-fidelity-document-rendering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/html_renderer.py
  - app/api/routes.py
autonomous: true

must_haves:
  truths:
    - "DOCX files are converted to high-fidelity HTML preserving formatting"
    - "Automatic numbering (1.1, 11.3.1) renders correctly"
    - "HTML is cached after first conversion"
    - "Paragraph IDs are injected for click handling"
  artifacts:
    - path: "app/services/html_renderer.py"
      provides: "docx-parser-converter wrapper with caching"
      exports: ["render_document_html", "render_precedent_html"]
    - path: "app/api/routes.py"
      provides: "HTML serving endpoints"
      contains: ["/document/<session_id>/html", "/precedent/<session_id>/html"]
  key_links:
    - from: "app/api/routes.py"
      to: "app/services/html_renderer.py"
      via: "import and call render functions"
      pattern: "from app\\.services\\.html_renderer import"
---

<objective>
Create backend HTML rendering service using docx-parser-converter.

Purpose: Replace plain text document display with high-fidelity HTML that preserves all Word formatting including automatic numbering, indentation, fonts, and styles.

Output: New html_renderer.py service and Flask endpoints that convert DOCX to HTML and inject paragraph IDs for interactivity.
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/05-high-fidelity-document-rendering/05-RESEARCH.md

@app/services/document_service.py
@app/api/routes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HTML rendering service</name>
  <files>app/services/html_renderer.py</files>
  <action>
Create a new service module `app/services/html_renderer.py`:

```python
"""
HTML Renderer Service

Converts DOCX files to high-fidelity HTML using docx-parser-converter.
Preserves formatting, automatic numbering, indentation, and styles.
"""

import re
from pathlib import Path
from typing import List, Optional
from docx_parser_converter import docx_to_html


def inject_paragraph_ids(html: str, paragraph_ids: List[str]) -> str:
    """
    Add data-para-id attributes to paragraphs for click handling.

    Maps rendered HTML paragraphs to document paragraph IDs so clicking
    a paragraph in the preview triggers the correct risk sidebar.
    """
    para_index = 0

    def replace_p(match):
        nonlocal para_index
        if para_index < len(paragraph_ids):
            para_id = paragraph_ids[para_index]
            para_index += 1
            # Inject data attribute into opening <p tag
            return f'<p data-para-id="{para_id}"'
        return match.group(0)

    return re.sub(r'<p(?=[\s>])', replace_p, html)


def add_preview_wrapper(html: str) -> str:
    """
    Wrap the HTML body content for embedding in the app.

    Extracts just the <main> content and adds our preview class.
    """
    # Extract content between <main> tags if present
    main_match = re.search(r'<main[^>]*>(.*?)</main>', html, re.DOTALL)
    if main_match:
        content = main_match.group(1)
    else:
        # Extract body content
        body_match = re.search(r'<body[^>]*>(.*?)</body>', html, re.DOTALL)
        content = body_match.group(1) if body_match else html

    # Extract styles from head
    style_match = re.search(r'<style[^>]*>(.*?)</style>', html, re.DOTALL)
    styles = style_match.group(1) if style_match else ''

    return f'''<style>
.document-preview {{
    font-family: 'Calibri', 'Arial', sans-serif;
    line-height: 1.5;
    padding: 0.75in;
    background: white;
}}
.document-preview p {{ margin: 0; }}
.document-preview .list-marker {{ font-weight: normal; }}
{styles}
</style>
<div class="document-preview">{content}</div>'''


def render_document_html(docx_path: str, paragraph_ids: Optional[List[str]] = None,
                         use_cache: bool = True) -> str:
    """
    Convert DOCX to high-fidelity HTML.

    Args:
        docx_path: Path to the DOCX file
        paragraph_ids: List of paragraph IDs to inject for click handling
        use_cache: Whether to use/create cached HTML

    Returns:
        HTML string ready for browser display
    """
    docx_path = Path(docx_path)
    cache_path = docx_path.with_suffix('.rendered.html')

    # Check cache
    if use_cache and cache_path.exists():
        # Cache exists - but we need to re-inject IDs if provided
        html = cache_path.read_text(encoding='utf-8')
        if paragraph_ids:
            # Re-inject IDs (they may have changed)
            html = inject_paragraph_ids(html, paragraph_ids)
        return html

    # Convert DOCX to HTML using docx-parser-converter
    raw_html = docx_to_html(str(docx_path))

    # Wrap for preview display
    html = add_preview_wrapper(raw_html)

    # Inject paragraph IDs if provided
    if paragraph_ids:
        html = inject_paragraph_ids(html, paragraph_ids)

    # Cache the result (without IDs - they get injected on read)
    if use_cache:
        cache_path.write_text(add_preview_wrapper(raw_html), encoding='utf-8')

    return html


def render_precedent_html(docx_path: str, paragraph_ids: Optional[List[str]] = None,
                          use_cache: bool = True) -> str:
    """
    Convert precedent DOCX to high-fidelity HTML.

    Same as render_document_html but uses separate cache file.
    """
    docx_path = Path(docx_path)
    cache_path = docx_path.with_suffix('.precedent.html')

    # Check cache
    if use_cache and cache_path.exists():
        html = cache_path.read_text(encoding='utf-8')
        if paragraph_ids:
            html = inject_paragraph_ids(html, paragraph_ids)
        return html

    # Convert DOCX to HTML
    raw_html = docx_to_html(str(docx_path))

    # Wrap for preview display
    html = add_preview_wrapper(raw_html)

    # Inject paragraph IDs if provided
    if paragraph_ids:
        html = inject_paragraph_ids(html, paragraph_ids)

    # Cache the result
    if use_cache:
        cache_path.write_text(add_preview_wrapper(raw_html), encoding='utf-8')

    return html


def clear_html_cache(docx_path: str) -> None:
    """Clear cached HTML files for a document."""
    docx_path = Path(docx_path)
    for suffix in ['.rendered.html', '.precedent.html']:
        cache_path = docx_path.with_suffix(suffix)
        if cache_path.exists():
            cache_path.unlink()
```
  </action>
  <verify>
Test in Python REPL:
```python
from app.services.html_renderer import render_document_html
from pathlib import Path

# Find a test document
uploads = Path('app/data/uploads')
docx_files = list(uploads.glob('**/*.docx'))
if docx_files:
    html = render_document_html(str(docx_files[0]))
    print(f"HTML length: {len(html)}")
    print("Contains list-marker:", 'list-marker' in html)
    print("Contains document-preview:", 'document-preview' in html)
```
  </verify>
  <done>
html_renderer.py exists with render_document_html and render_precedent_html functions. Caching works. Paragraph ID injection works.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add HTML endpoints to routes</name>
  <files>app/api/routes.py</files>
  <action>
Add two new endpoints to routes.py for serving rendered HTML:

1. **Add import at top of routes.py:**
```python
from app.services.html_renderer import render_document_html, render_precedent_html
```

2. **Add document HTML endpoint:**
```python
@api_bp.route('/document/<session_id>/html', methods=['GET'])
def serve_document_html(session_id):
    """
    Serve high-fidelity HTML version of target document.

    Uses docx-parser-converter to preserve all formatting including
    automatic numbering, indentation, fonts, and styles.
    RENDER-01, RENDER-02, RENDER-03: High-fidelity document preview
    """
    session = get_session(session_id)
    if not session:
        return jsonify({'error': 'Session not found'}), 404

    target_path = session.get('target_path')
    if not target_path or not Path(target_path).exists():
        return jsonify({'error': 'Document not found'}), 404

    # Get paragraph IDs from parsed document for click handling
    doc_data = session.get('document', {})
    paragraph_ids = [
        item['id'] for item in doc_data.get('content', [])
        if item.get('type') == 'paragraph'
    ]

    try:
        html = render_document_html(target_path, paragraph_ids)
        return Response(html, mimetype='text/html; charset=utf-8')
    except Exception as e:
        return jsonify({'error': f'HTML rendering failed: {str(e)}'}), 500
```

3. **Add precedent HTML endpoint:**
```python
@api_bp.route('/precedent/<session_id>/html', methods=['GET'])
def serve_precedent_html(session_id):
    """
    Serve high-fidelity HTML version of precedent document.

    RENDER-04: Same rendering engine for both panels
    """
    session = get_session(session_id)
    if not session:
        return jsonify({'error': 'Session not found'}), 404

    precedent_path = session.get('precedent_path')
    if not precedent_path or not Path(precedent_path).exists():
        return jsonify({'error': 'Precedent document not found'}), 404

    # Get paragraph IDs from parsed precedent for click handling
    prec_data = session.get('precedent_document', {})
    paragraph_ids = [
        item['id'] for item in prec_data.get('content', [])
        if item.get('type') == 'paragraph'
    ]

    try:
        html = render_precedent_html(precedent_path, paragraph_ids)
        return Response(html, mimetype='text/html; charset=utf-8')
    except Exception as e:
        return jsonify({'error': f'HTML rendering failed: {str(e)}'}), 500
```

4. **Add Response import if not present:**
```python
from flask import Response  # Add to existing imports
```
  </action>
  <verify>
1. Start Flask server: `python -m app.server`
2. Upload a document through the app
3. Note the session_id
4. Test endpoint:
```bash
curl -s "http://localhost:5000/api/document/{SESSION_ID}/html" | head -50
```
Should return HTML with `document-preview` class and `list-marker` spans.
  </verify>
  <done>
Two endpoints exist: /document/{session_id}/html and /precedent/{session_id}/html. Both return high-fidelity HTML with paragraph IDs injected.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify HTML output quality</name>
  <files>None (testing only)</files>
  <action>
Test the complete rendering pipeline with a real legal document:

1. Start the Flask server
2. Upload a contract document through the intake form
3. Get the session_id from the URL
4. Open the HTML endpoint directly in browser:
   `http://localhost:5000/api/document/{session_id}/html`

Verify:
- [ ] Automatic numbering displays correctly (1.1, 1.2, 11.3.1, etc.)
- [ ] Indentation is preserved
- [ ] Fonts render appropriately (Times New Roman or fallback)
- [ ] Bold and underline text appears correctly
- [ ] Text alignment (justify, center) works
- [ ] Paragraph IDs are present: inspect HTML for `data-para-id` attributes

If issues found, debug and fix in html_renderer.py.
  </action>
  <verify>
HTML renders with correct formatting in browser. Paragraph IDs are present in DOM.
  </verify>
  <done>
End-to-end test passes: document renders with high fidelity, automatic numbering correct, paragraph IDs present.
  </done>
</task>

</tasks>

<verification>
- [ ] html_renderer.py exists with docx-parser-converter integration
- [ ] /document/{session_id}/html endpoint returns formatted HTML
- [ ] /precedent/{session_id}/html endpoint returns formatted HTML
- [ ] Automatic numbering (1.1, 11.3.1) renders correctly
- [ ] Paragraph IDs are injected for click handling
- [ ] HTML caching works (second request is fast)
</verification>

<success_criteria>
1. Backend converts DOCX to HTML preserving all formatting
2. Automatic numbering schemes render correctly (critical requirement)
3. Both target and precedent documents have HTML endpoints
4. Paragraph IDs enable click-to-select functionality
5. Caching prevents redundant conversion
</success_criteria>

<output>
After completion, create `.planning/phases/05-high-fidelity-document-rendering/05-01-SUMMARY.md`
</output>
