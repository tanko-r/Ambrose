---
phase: 05-high-fidelity-document-rendering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/pdf_service.py
  - app/api/routes.py
autonomous: true

must_haves:
  truths:
    - "DOCX files can be converted to PDF via the backend"
    - "PDF files are cached after first conversion"
    - "API endpoint returns PDF for a given session's document"
  artifacts:
    - path: "app/services/pdf_service.py"
      provides: "LibreOffice headless conversion logic"
      exports: ["convert_docx_to_pdf", "get_or_create_pdf"]
    - path: "app/api/routes.py"
      provides: "PDF serving endpoint"
      contains: "/document/<session_id>/pdf"
  key_links:
    - from: "app/api/routes.py"
      to: "app/services/pdf_service.py"
      via: "import and call get_or_create_pdf"
      pattern: "from app\\.services\\.pdf_service import"
---

<objective>
Create the backend PDF conversion service using LibreOffice headless.

Purpose: Enable high-fidelity document rendering by converting DOCX to PDF server-side, preserving all formatting including automatic numbering that JavaScript libraries cannot reliably render.

Output: A new pdf_service.py module and a Flask endpoint that converts DOCX to PDF on first request and serves cached PDFs thereafter.
</objective>

<execution_context>
@C:\Users\david\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\david\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-high-fidelity-document-rendering/05-RESEARCH.md

@app/services/document_service.py
@app/api/routes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PDF conversion service</name>
  <files>app/services/pdf_service.py</files>
  <action>
Create a new service module `app/services/pdf_service.py` with:

1. **libreoffice_exec()** function:
   - Returns correct path for Windows: `C:\Program Files\LibreOffice\program\soffice.exe`
   - Include fallback paths for common installation locations
   - Raise clear error if LibreOffice not found

2. **convert_docx_to_pdf(docx_path, output_dir=None)** function:
   - Takes path to DOCX file
   - Uses subprocess to call LibreOffice headless:
     ```
     soffice --headless --convert-to pdf --outdir {output_dir} {docx_path}
     ```
   - Sets timeout of 60 seconds (generous for large docs)
   - Verifies output PDF exists (LibreOffice returns 0 even on failure)
   - Returns path to generated PDF
   - Raises RuntimeError with stderr if conversion fails

3. **get_or_create_pdf(session_id, docx_path)** function:
   - Checks if PDF already exists at `{docx_path.parent}/{docx_path.stem}.pdf`
   - If exists, returns path immediately (cache hit)
   - If not, calls convert_docx_to_pdf and returns new path
   - Logs conversion time for performance monitoring

IMPORTANT: Do NOT use concurrent LibreOffice calls - the library cannot handle them. This is acceptable for single-user local app usage.
  </action>
  <verify>
Run in Python REPL:
```python
from app.services.pdf_service import libreoffice_exec, convert_docx_to_pdf
print(libreoffice_exec())  # Should print path to soffice.exe
```
Verify the function doesn't raise an error (LibreOffice must be installed).
  </verify>
  <done>
pdf_service.py exists with all three functions. libreoffice_exec() returns valid path on Windows. convert_docx_to_pdf() signature matches research spec.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add PDF endpoint to routes</name>
  <files>app/api/routes.py</files>
  <action>
Add a new endpoint to routes.py:

```python
@api_bp.route('/document/<session_id>/pdf', methods=['GET'])
def serve_document_pdf(session_id):
    """
    Serve PDF version of target document for high-fidelity rendering.

    Converts DOCX to PDF on first request, caches for subsequent requests.
    RENDER-01, RENDER-02, RENDER-03: High-fidelity document preview
    """
```

Implementation:
1. Get session using existing get_session() helper
2. Return 404 if session not found
3. Get target_path from session
4. Call get_or_create_pdf(session_id, target_path)
5. Return PDF using Flask's send_file() with:
   - mimetype='application/pdf'
   - as_attachment=False (inline viewing)
6. Catch exceptions and return 500 with error message

Add import at top of routes.py:
```python
from app.services.pdf_service import get_or_create_pdf
```

ALSO add a second endpoint for precedent PDF:

```python
@api_bp.route('/precedent/<session_id>/pdf', methods=['GET'])
def serve_precedent_pdf(session_id):
    """Serve PDF version of precedent document for RENDER-04."""
```

Same logic but uses session['precedent_path'] instead.
  </action>
  <verify>
Start the Flask server and test:
```bash
curl -I http://localhost:5000/api/document/{test_session_id}/pdf
```
Should return 200 with Content-Type: application/pdf (or 404 if no session).

For a real test with a session:
1. Upload a document via intake
2. Request /api/document/{session_id}/pdf
3. Verify PDF is returned and opens correctly
  </verify>
  <done>
Two new endpoints exist: /document/{session_id}/pdf and /precedent/{session_id}/pdf. Both return valid PDFs converted from the uploaded DOCX files.
  </done>
</task>

<task type="auto">
  <name>Task 3: Test PDF conversion end-to-end</name>
  <files>None (testing only)</files>
  <action>
Create a manual test to verify the full pipeline works:

1. Start the Flask server: `python -m app.server`
2. Open browser to localhost:5000
3. Upload a test contract document (any .docx file)
4. Note the session_id from the response
5. In a new tab, navigate to: `http://localhost:5000/api/document/{session_id}/pdf`
6. Verify:
   - PDF opens in browser (or downloads)
   - Formatting is preserved (fonts, spacing, indentation)
   - Automatic numbering renders correctly (1.1, (a), (i), etc.)

If any step fails, debug and fix the issue.

Also verify caching works:
1. Request the same PDF URL again
2. Check that response is near-instant (cached PDF served)
  </action>
  <verify>
PDF renders correctly in browser with preserved formatting. Second request is fast (cache hit).
  </verify>
  <done>
End-to-end test passes: DOCX uploads, converts to PDF, PDF displays with correct formatting, cache works.
  </done>
</task>

</tasks>

<verification>
- [ ] pdf_service.py exists and has convert_docx_to_pdf function
- [ ] LibreOffice executable is found on Windows
- [ ] /document/{session_id}/pdf endpoint returns valid PDF
- [ ] /precedent/{session_id}/pdf endpoint returns valid PDF
- [ ] PDF caching works (second request is fast)
- [ ] PDF preserves formatting from original DOCX
</verification>

<success_criteria>
1. Backend can convert any uploaded DOCX to PDF using LibreOffice
2. PDF is cached after first conversion (no re-conversion on subsequent requests)
3. Both target and precedent documents have PDF endpoints
4. Conversion completes within 10 seconds for typical legal documents
5. Error handling returns meaningful messages when conversion fails
</success_criteria>

<output>
After completion, create `.planning/phases/05-high-fidelity-document-rendering/05-01-SUMMARY.md`
</output>
